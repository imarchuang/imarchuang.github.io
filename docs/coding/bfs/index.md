# 宽度搜素：层级遍历，最短距离，拓扑排序

### **浅谈遍历的思维**
**只要上过算法课的人，都会晓得深搜(DFS)和宽搜(BFS)。就这么说吧，搜索就是穷举遍历的过程，只不过有时候穷举遍历的过程中发现了可以exit的条件可以提前结束而已。宽搜的本质是面（或者说由点及面），属于集体作战。深搜的话属于一条线走到天黑，属于单打独斗。这篇主要是想借着[东哥的这篇帖子(一文秒杀所有岛屿题目)](https://labuladong.gitee.io/algo/4/30/111/)来整理加深一下DFS和BFS之间的不同作战规则。这里的题都是基于矩阵（也是图）的遍历，所以遍历起来的方向性也比较容易理解。**

> **建议刷完二叉树的同学再来读这篇文章，会有更深刻的理解。**

东哥展示了DFS的思路和写法，我想借着这篇帖子同时展示一下DFS和BFS，以便日后容易复习理解。

!> 先上个结论：好多人觉得DFS更通用，BFS只是在无权有向图的最短路径类题里作用比较大，我个人觉得能用BFS的地方就别用DFS。

> 刷二叉树相关问题的时候，一直强调二叉树的90%的题都是DFS，是锻炼递归思维的最佳选择。这里再提一下二叉树的一些“优势”特点让它的DFS写起来容易：
> 1. 二叉树的`选择列表`只有两项：左儿子和右儿子，所以不需要for循环处理；
> 2. 二叉树只有父节点指向子节点的指针，所以不存在`重复访问`的问题；
> 3. 二叉树的每个节点都最多只有1个父节点，所以`不存在重复字问题`的；

二叉树的问题也有几道是层级遍历题，就是BFS。

先上框架吧，
```js
// 二叉树遍历框架
// 所有二叉树的题都是下列模板的巧妙变形套用
const traverse = (TreeNode root) => {
    if (!root) {
        return; //如果是分治法，返回向右的空节点时候赋值
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
}

// 二维矩阵遍历框架
const dfs = (grid, i, j, visited) => {
    let m = grid.length, n = grid[0].length;
    if (i < 0 || j < 0 || i >= m || j >= n) {
        // 超出索引边界
        return;
    }
    if (visited[i][j]) {
        // 已遍历过 (i, j)
        return;
    }
    // 进入节点 (i, j)
    visited[i][j] = true;
    dfs(grid, i - 1, j, visited); // 上
    dfs(grid, i + 1, j, visited); // 下
    dfs(grid, i, j - 1, visited); // 左
    dfs(grid, i, j + 1, visited); // 右
}
```

### 知识要点列表
1. [二叉树的层级遍历](./levels.md)
1. [YYDS, 拓扑排序](./topsort.md)

### **刷题列表**
1. [200. 岛屿数量（中等）](#岛屿数量)
1. [1254. 统计封闭岛屿的数目（中等）](#统计封闭岛屿的数目)
1. [1020. 飞地的数量（中等）](#飞地的数量)
1. [695. 岛屿的最大面积（中等）](#岛屿的最大面积)
1. [1905. 统计子岛屿（中等）](#统计子岛屿)
1. [694. 不同的岛屿数量（中等）](#不同的岛屿数量)
