# 数组题的小技巧

## 数组都考啥？
>数组吧，涉及到各种算法类型，但是这里讲讲非回溯、动规、或者分治类思想的一些数组问题处理技巧，这里主要是讲当你能很快地想成暴力算法的解法时候，发现暴力解时多项式级别的时间复杂度，比如说`O(n^2)`, `O(nlogn)`甚至`O(n)`，这时候你需要followup思考更优解。

### 数组双指针
>说到数组，你应该一下就想到双指针。我们先来唠唠**两头到中间**的双指针。这里最有名的就是**nSum类**问题了，2Sum时候你还侥幸的觉得我不需要对数组进行排序，用一个hashmap做缓存进行complement的查询就好了，对吧？到了3Sum或者其他变种的时候，你就发现**有序**是多么的重要，要不你就只能暴力的穷举是复杂度肯定超过O(nlogn)对吧？甭管几数之和，解法肯定要穷举所有的**数字组合**，然后看看那个数字组合的和等于目标和嘛。你在想数字组合嘛，那不就是回溯框架嘛，那请问你是否记得回溯算法里找数字组合的复杂度呢？话说回来，你应该还记得用**回溯框架**的时候你肯定是先**sort**了你的输入数组对吧？因为只有这样才好**回溯框架里去重**。但是**nSum类**的题型里是想告诉你，当你把你的数组变成**有序**之后，你可以讨巧的运用双指针进行运算，因为这个**有序**才使你的指针移动的规则变得非常清晰。

### 数组双指针 之 二分法
>说到这儿了，你会发现**有序**的东西会使问题变得更**有章可循**。那我就顺着这个思路说说**二分搜索算法**吧，二分搜索比双指针更讨巧，因为**数组有序**嘛，你可以直接先**猜**你想要的结果在中间对吧？如果没猜对，那好办至少你知道往左移还是往右移对吧？所以**二分搜索**里讲到的`OOXX`，`drop一半`，`二分答案`呀之类的题型，其实都是告诉你你要先想清楚你的**有序**是咋个样子的，数学上这个叫做找到**单调函数**或者找到**二元临界值**。

### 数组双指针 之 老猛男
>现在说完了利用**有序**到有章可循的从**两头到中间**的双指针，我们再来唠唠**滑动窗口老猛男**。它其实是个快慢指针的一种，主要用来处理子串、子数组问题。之所以好用，主要是因为题目的要求通常可以用**窗口**内的所有元素状态来判断**啥时候需要扩大或者缩小**窗口。这里所谓的`所有元素状态`的例子就是：窗口里的元素都是**unique**的，串口的大小不能超过**某size**之类的。这里用的思想不是**有序**，而是**窗口扩容和缩减**是符合某种规则的。
>
>既然提到快慢指针了，我就更概括一下。**快慢指针**最著名的就是可以用来判断链表中是否有环，但是这个其实还不够抽象，更抽象一点即是说：**给你一个函数，它本身输入和输出是同数据类型的，那么你就可以递归式的call这个函数N层**，比如说链表对吧，`node.next`返回的还是Node类型，所以你可以叫`node.next.next`对吧？现在假设给你的是这么一个函数`int isHappyNumber(int a)`，那你是否意识到你可以这么call这个函数呢？`isHappyNumber(isHappyNumber(a))`；所以说所谓的快慢指针并不是非得是指针。
>
>当然了，像`找链表的中点`这种问题时候，你能否想到用快慢双指针那就真是难者不会会者不难了。
>
>说完快慢指针了，现在得说说**从中间往两端**的双指针，这种思路最典型的例子就是寻找最长回文子串，就是**从中心向两端扩散**。再反过来提一下，如果是判断一个串是否是回文串，那就使用双指针从两端向中心检查。

### 数组技巧 之 前缀和 & 差分数组
>最后了说说**前缀和**还有**差分数组**吧。**前缀和**嘛，就是让你用空间换时间，这里当你需要**频繁地**计算子数组的`sum和`时候，你就发现我直接从前缀和presum这个**预处理**好的cache里找就好了。当然了，**前缀和**也可以是**后缀和**对吧？看你从前端还是后端遍历嘛。类似的，当你需要**频繁地**对子数组进行`增减操作`，就需要维护一个**差分数组**做cache来避免循环了。
>

**数组题太多了，涉及到各种算法类型，这篇就讲讲比较具有技巧性的一些数组题** 

### 前缀和数组
> 前缀和的思想是**空间换时间**的另一种典范，说道cache啊，memo啊之类的，你肯定会想到`Tree`，`Map`，`PQ`之类的*高级*结构，这个前缀和presum比较单纯，就是一个数组就能承载缓存，多奇妙之说。前缀和肯定也可以是**后缀和**，主要是看你遍历的方向。
>
> 那么前缀和这么好使，但是说实话你却不太容易意识到需要用到它。这里就粗狂的总结一下吧，可能目前还不太准确：
>1.题中出现了需要**区间**的概念，然后你算得是区间里所有元素之和，说白了就是**子数组的和**；
>1.题中的**区间**之边界是变化的，[i,j]变化是非常**频繁地**。
>
>
[Rippling面试真题 - 矩阵内前缀和]()
>**原题** 给你一个矩阵，比如说input_matrix=[[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]，再给你一个参数r=1，r代表的是**半径**，让你求**半径**范围内的所有数的总和，基于上例，答案就是output_matrix=[[4,6,6,6,4],[6,9,9,9,6],[6,9,9,9,6],[4,6,6,6,4]]。
>
>**思路** 这题的暴力思路非常简单，那就是遍历矩阵中的每个节点，然后基于这个节点matrix[i][j]分别向**8个方向**各走r步，最后加上自身值那就是基于这个节点的所谓的**面积了**，这样做的时间复杂度是`O(m*n*8r)`，这是比较无脑的暴力解，但是如果你仔细画图看一下你就发现这**8个方向**其实是有漏洞的，我接住画图来演示一下：

> 假设r=1，给你一个3x3的矩阵，那么你最中心位置元素的面积可以这么穷举遍历:
> 
```
 O  O  O
  \ | /
 O- X -O
  / | \
 O  O  O
```
>
> 假设r=2，给你一个5x5的矩阵，那么你最中心位置元素的面积如果你继续按照**8个方向**穷举遍历，其实是不对的（图中标记为M的点就是遍历不到的节点）:
> 
```
O   M   O   M   O
  \     |     /
M   O   O   O   M
      \ | /
O - O - X - O - O
      / | \
M   O   O   O   M
  /     |     \
O   M   O   M   O
```
> 这也就是说，让你求面积的时候，如果你按照**圆心**的思维计算，但你的半径r越大，你可能miss的点会更多；这时候呢你要回归数学思维，这个r其实是某个可能的正方形边长的一半，求正方形的面积你会算吧？`长x宽`对吧？有了这个思维，你至少应该开始考虑这是两个方向的遍历了。多数人的大脑都是这么被训练的，比如说在长度（即横向维度）上遍历**2r步**（注意边界即可），然后再在宽度（即纵向维度）上遍历**2r步**（也要注意边界即可）。到这里了，我觉得才算有了暴力解的思路了。
>
> 暴力解的问题的话，就是针对每个节点你都需要计算`2r*2r`个节点之和，所以总的时间复杂度就是`O(m*n*4r^2)`，看到这儿了，聪明的你应该会想到了**前缀和**数组的用处了。也就是说当你在横向维度上遍历**2r步**的时候，你发现你其实做的某个区间内的sum计算，而且每个节点都做只是区间边界有所变化，这正是前缀和数组的用武之地！你脑子里先闪现这么一个过度矩阵吧：
```js
const preSums=[
  [1,2,3,4,5],
  [1,2,3,4,5],
  [1,2,3,4,5],
  [1,2,3,4,5]
]
```
> 借助于这个前缀和矩阵preSums，当你在横向维度上遍历**2r步**的时候，你就可以用常数时间复杂度求得某个区间`(start-1, end]`区间内的和了。这样就可以只走一个方向，即自上而下，这样我们就可以将时间复杂度降到`O(m*n*2r)`，直接看代码会比较直接：
>
> **后记** 这题在面试中，很多面试者会话相当长的时间理解问题，所以这一部分考验的是如何技巧性的问面试官，让面试官没有机会给你*误导信号*。
```java
class Solution{
  private static int[][] getRegionSum(int[][] matrix, int r){
    int m=matrix.length, n=matrix[0].length;
    int[][] preSum = new int[m][n];
    int[][] res = new int[m][n];

    //init presum
    for(int i=0; i<m; i++)
      preSum[i][0] = matrix[i][0];

    for(int i=0; i<m; i++)
      for(int j=1; j<n; j++)
        preSum[i][j] = preSum[i][j-1] + matrix[i][j];
    
    //fill up res
    for(int i=0; i<m; i++)
      for(int j=0; j<n; j++){
        int rowBegin = i-r<0?0:i-r, rowEnd = i+r>m-1?m-1:i+r;
        int colBegin = j-r<0?0:j-r, colEnd = j+r>n-1?n-1:j+r;

        int interim = 0;
        for(int k=rowBegin; k<=rowEnd; k++)
          interim += (preSum[k][colEnd] - (colBegin==0? 0 : preSum[k][colBegin-1]));
        
        res[i][j] = interim;
      }

    return res;
  }
}
```

### 差分数组

### 数学知识点
[领扣1149 有效的正方形](https://www.lintcode.com/problem/1149)
> **思路** 正方形的特性：4个边长相等，2个对角线距离相等；
```java
public class Solution {
    /**
     * @param p1: the first point
     * @param p2: the second point
     * @param p3: the third point
     * @param p4: the fourth point
     * @return: whether the four points could construct a square
     */
    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {
        int[][] points = new int[][]{p1,p2,p3,p4};

        int[] res = new int[6];
        int cnt = 0;
        for(int i=0; i<3; i++){
          for(int j=i+1; j<4; j++){
            int dis = (points[i][0]-points[j][0])*(points[i][0]-points[j][0]) 
                      + (points[i][1]-points[j][1])*(points[i][1]-points[j][1]);
            res[cnt++] = dis;
          }
        }

        Arrays.sort(res);

        return (res[0]==res[3] && res[4]==res[5] && res[5]>res[0]);
    }
}
```