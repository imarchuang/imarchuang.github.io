# 数组题的小技巧

### 数组都考啥？
>数组吧，涉及到各种算法类型，但是这里讲讲非回溯、动规、或者分治类思想的一些数组问题处理技巧，这里主要是讲当你能很快地想成暴力算法的解法时候，发现暴力解时多项式级别的时间复杂度，比如说O(n^2), O(nlogn)甚至O(n)，这时候你需要followup思考更优解。
>
>说到数组，你应该一下就想到双指针。我们先来唠唠**两头到中间**的双指针。这里最有名的就是**nSum类**问题了，2Sum时候你还侥幸的觉得我不需要对数组进行排序，用一个hashmap做缓存进行complement的查询就好了，对吧？到了3Sum或者其他变种的时候，你就发现**有序**是多么的重要，要不你就只能暴力的穷举是复杂度肯定超过O(nlogn)对吧？甭管几数之和，解法肯定要穷举所有的**数字组合**，然后看看那个数字组合的和等于目标和嘛。你在想数字组合嘛，那不就是回溯框架嘛，那请问你是否记得回溯算法里找数字组合的复杂度呢？话说回来，你应该还记得用**回溯框架**的时候你肯定是先sort了你的输入数组对吧？因为只有这样才好**去重**。但是nSum类的题型里是想告诉你，当你把你的数组变成**有序**之后，你可以讨巧的运用双指针进行运算，因为这个有序是你的指针移动的规则变得非常清晰。
>
>说到这儿了，你会发现**有序**的东西会使问题变得更**有章可循**。那我就顺着这个思路说说**二分搜索算法**吧，二分搜索比双指针更讨巧，因为**数组有序**嘛，你可以直接先**猜**你想要的结果在中间对吧？如果没猜对，那好办至少你知道往左移还是往右移对吧？所以**二分搜索**里讲到的`OOXX`，`drop一半`，`二分答案`呀之类的题型，其实都是告诉你你要先想清楚你的**有序**是咋个样子的，数学上这个叫做找到**单调函数**或者找到**二元临界值**。
>
>现在说完了利用**有序**到有章可循的从**两头到中间**的双指针，我们再来唠唠**滑动窗口老猛男**。它其实是个快慢指针的一种，主要用来处理子串问题。之所以好用，主要是因为题目的要求通常可以用**窗口**内的所有元素状态来判断**啥时候需要扩大或者缩小**窗口。这里所谓的`所有元素状态`的例子就是：窗口里的元素都是unique的，串口的大小不能超过某size之类的。这里用的思想不是**有序**，而是**窗口扩容和缩减**是符合某种规则的。
>
>既然提到快慢指针了，我就更概括一下。**快慢指针**最著名的就是可以用来判断链表中是否有环，但是这个其实还不够抽象，更抽象一点即是说：**给你一个函数，它本身输入和输出是同数据类型的，那么你就可以递归式的call这个函数N层**，比如说链表对吧，`node.next`返回的还是Node类型，所以你可以叫`node.next.next`对吧？现在假设给你的是这么一个函数`int isHappyNumber(int a)`，那你是否意识到你可以这么call这个函数呢？`isHappyNumber(isHappyNumber(a))`；所以说所谓的快慢指针并不是非得是指针。
>
>当然了，像`找链表的中点`这种问题时候，你能否想到用快慢双指针那就真是难者不会会者不难了。
>
>说完快慢指针了，现在得说说**从中间往两端**的双指针，这种思路最典型的例子就是寻找最长回文子串，就是**从中心向两端扩散**。再反过来提一下，如果是判断一个串是否是回文串，那就使用双指针从两端向中心检查。
>
>最后了说说**前缀和**还有**差分数组**吧。**前缀和**嘛，就是让你用空间换时间，这里当你需要**频繁地**计算子数组的和时候，你就发现我直接从前缀和这个**预处理**好的cache里找就好了。当然了，**前缀和**也可以是**后缀和**对吧？看你从前端还是后端遍历嘛。类似的，当你需要**频繁地**对子数组进行`增减操作`，就需要维护一个**差分数组**做cache来避免循环了。
>

**数组题太多了，涉及到各种算法类型，这篇就讲讲比较具有技巧性的一些数组题** 

### 前缀和数组
> 前缀和的思想是空间换时间的另一种典范，这个前缀和不用什么Tree，Map，PQ之类的“高级”结构，单纯的一个数组就能承载，多奇妙之说。前缀和肯定也可以是**后缀和**，主要是看你遍历的方向。
>
> 那么前缀和这么好使，但是说实话你却不太容易意识到需要用到它。这里就粗狂的总结一下吧，可能目前还不太准确：
>1.题中出现了需要**区间**的概念，然后你算得是区间里所有元素之和，说白了就是子数组的和；
>1.题中的**区间**之边界是变化的，[i,j]变化是非常**频繁地**。
>
>
[Rippling面试真题 - 矩阵内前缀和]()
>**原题** 给你一个矩阵，比如说input_matrix=[[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]，再给你一个参数r=1，r代表的是“半径”，让你求“半径”范围内的所有数的总和，基于上例，答案就是output_matrix=[[4,6,6,6,4],[6,9,9,9,6],[6,9,9,9,6],[4,6,6,6,4]]。
>
>**思路** 这题的暴力思路非常简单，那就是遍历矩阵中的每个节点，然后基于这个节点matrix[i][j]分别向**8个方向**各走r步，最后加上自身值那就是基于这个节点的“面积了”，这样做的时间复杂度是`O(m*n*8r)`，但是这题能否优化呢？
>
>答案是有的，只不过是非量级优化，那就是可以先预设一个前缀和矩阵，都是基于横向数组的，那么你就避免了走8个方向，这样就可以只走一个方向，即自上而下，这样我们就可以将时间复杂度降到`O(m*n*2r)`，直接看代码会比较直接：
```java
class Solution{
  private static int[][] getRegionSum(int[][] matrix, int r){
    int m=matrix.length, n=matrix[0].length;
    int[][] preSum = new int[m][n];
    int[][] res = new int[m][n];

    //init presum
    for(int i=0; i<m; i++)
      preSum[i][0] = matrix[i][0];

    for(int i=0; i<m; i++)
      for(int j=1; j<n; j++)
        preSum[i][j] = preSum[i][j-1] + matrix[i][j];
    
    //fill up res
    for(int i=0; i<m; i++)
      for(int j=0; j<n; j++){
        int rowBegin = i-r<0?0:i-r, rowEnd = i+r>m-1?m-1:i+r;
        int colBegin = j-r<0?0:j-r, colEnd = j+r>n-1?n-1:j+r;

        int interim = 0;
        for(int k=rowBegin; k<=rowEnd; k++)
          interim += (preSum[k][colEnd] - (colBegin==0? 0 : preSum[k][colBegin-1]));
        
        res[i][j] = interim;
      }

    return res;
  }
}
```

### 差分数组

### 数学知识点
[领扣1149 有效的正方形](https://www.lintcode.com/problem/1149)
> **思路** 正方形的特性：4个边长相等，2个对角线距离相等；
```java
public class Solution {
    /**
     * @param p1: the first point
     * @param p2: the second point
     * @param p3: the third point
     * @param p4: the fourth point
     * @return: whether the four points could construct a square
     */
    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {
        int[][] points = new int[][]{p1,p2,p3,p4};

        int[] res = new int[6];
        int cnt = 0;
        for(int i=0; i<3; i++){
          for(int j=i+1; j<4; j++){
            int dis = (points[i][0]-points[j][0])*(points[i][0]-points[j][0]) 
                      + (points[i][1]-points[j][1])*(points[i][1]-points[j][1]);
            res[cnt++] = dis;
          }
        }

        Arrays.sort(res);

        return (res[0]==res[3] && res[4]==res[5] && res[5]>res[0]);
    }
}
```