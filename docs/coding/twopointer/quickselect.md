# 关于快排快选

**这篇主要是深入讲解传说中的partition算法**
>
>我们之前讲过**归并排序**，核心思想就是**先把左半边数组排好序，再把右半边排好序，然后把两个数组合并**。这种分治的思想应该算是计算机最最最基础的算法思想之一，沿着这个思想，我们加深一下。何谓快排？简单来说，就是**先将一个元素排好序，再将剩下的元素排好序**，这里就有一个核心中的核心函数**partition**，顺着分治思想，就是给你一个数组nums，然后给你一个区间nums[lo...hi]，让你在其中找个分界点p，通过元素交换使得nums[lo...p-1]都小于等于nums[p]，且nums[p+1...hi]都大于nums[p]。
>
>这里的分治思想体现在哪儿？如果你能做到让一个元素nums[p]它的左边都比自己小，右边都比自己大，那是不是说nums[p]已经在正确的位置上了？那么这样同时也说明问题是不是切小了？因为它的左边和右边都是子数组，递归的思想就可以用在这儿了。
>
>分治分治嘛，我们就用**二叉树来形象的说明一下**。如果你知道nums[p]已经在正确的位置上了，那么是不是说明你可以把他左边的元素当做左儿子，右边的元素当做右儿子？然后再针对左右儿子分别进行快排。你是不是意识到了？这其实就是在构造一个二叉搜索树BST嘛！时间复杂度咋理解呢？最好的情况下，你每次都能将左儿子和右儿子平均的分开，也就是说说左儿子右儿子正好元素个数都近似上层数组的一半，这样树的高度就是logN，然后树的每层我们要处理N个元素，所以时间复杂度是O(N*logN)，但是最坏的情况是每次分拆之后，左儿子或者右儿子为空，这样你的树的高度就是N，最坏的时间复杂度就是O(N^2)。
>
>
>
>
>

>面试中直接让你用快排排列一个数组的可能性几乎为零，那面试都面啥啊？这就是传说中的**快选**！我们直接上最经典的问题吧，就是**找第k个最大的元素**，就是说给你一个数组，比如说nums=[2,1,5,4], 再给你一个k=2，让你写个函数能够返回4，因为4是nums数组中第2个最大的元素。
>
>先说说利用PQ的思路：你借助于一个大小为k的PQ(minHeap)，然后遍历数组并不断往PQ里塞元素，但是塞的过程中要记得维护PQ的size，说白了这个思路就是用PQ当筛子，小于第k个最大元素值得元素都会被筛出去。这样当遍历完素有元素了，PQ堆里最小的那个元素就是第k个最大元素了(因为是最小堆MinHeap)，这个思路的时间复杂度是O(n*logk)。
>
>上个思路基本上是当个引子，肯定会followup问你有无可优化的地方，这时候**快选**就是答案，当然你是怎么能过渡到快选的思路上来，这个只能说刷题经验和对计算机算法基础的厚度了。原题让你找第k大元素，那么如果你从小到达排序原数组，你要找的就是第`k'=n-k`个元素，这个很好理解吧？还记得**快排**的特性不？那就是每次你可以随机选一个元素当做BST的根节点，然后你至少能把小于等于这个根节点值的元素都放到左边，把大于这个根节点值的元素都放到右边，虽然这并没有把左右的子数组都排序了，但是至少你得到了一个很重要的统计数据，那就是根据你左边元素的个数确定你在整个数组的排序(**从小往大排**)，这就是**快排**里**partition**函数的奇妙之处，你只用了O(n)的时间就已经找到了某个元素的正确排序位置p，有了这个位置p，你是不是就一下可以做一个大胆的决定了？这里的决定就是类似于**二分法drop一半**的思路，那就是drop掉p的左边或者右边去寻找你要的答案。理想状态下，你希望看到的是每次能缩小的空间越多越好，所以你肯定希望每次机选的元素正好能够将原数组**等分切两半**，这样每次你就只剩N‘/2的元素要去遍历了，所以理想状态就是`N+N/2+N/4+N/8+...`，结果会是**2N**，所以你的算法的平均时间复杂度就能降维到O(N)上。这里强烈建议默写背诵**partition**函数的全文，因为这个写法的边界条件很具有技巧性。
```java
private int partition(int[] nums, int lo, int hi){
    
}
```
>
>
>
>
>