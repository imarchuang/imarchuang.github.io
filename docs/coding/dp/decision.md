# 决策类动规题型概论

### **敲黑板** 关于决策类动规的思考
> 决策，英文是Decsion Making，其实对当前元素取或者不取的决策。说到这里，你想的没错，背包类knapsack问题其实都是这类问题。不过从深层意义上来说，其实不止背包类动规是这个思想，其实有好多其他的类似思想应用。
>
> 问题描述多数是张这个样子的：`Given a set of values`, `find an answer with an option to chooose or ignore the current value`；
>
> 这类题的一个很重要思想就是，你通常有两个选择：`取`或者`不取`，这样你就要在这两种选择找最优的一种。不过再**说一点**，就是这个每个value上的两种选择可能会有限制，我会在股票买卖的问题系列里展示这个限制；
>

### 每个value上的选择都是`取`或者`不取`，最终答案存在一个子序里
> 先来看看经典的问题[198. 打家劫舍]()，这个问题的一个关键特性是每个房子里的都有**正数**的价值，然后题解要求抢最大值得价值，所以每抢一个房子，对答案肯定是增加价值的。假设房子的价值是这个数列`[10,1,9,19,9,7]`，我们用脑回路过一下这个`取`或者`不取`思想；
> 1. 如果没有任何房子，那能抢到的最大价值一定是`0`；--> 把这个结果存在dp[0]上；
> 1. 如果只有一个房子，那能抢到的最大价值一定是那个唯一房子里的价值`values[i]`；--> 把这个结果存在dp[1]上；
> 1. 如果有两个房子，你该怎么计算呢？当你迭代到`i=1`这个位置上（values数列里的第二个元素），你怎么判断能抢到的最大价值呢？两个元素似乎也是直截了当，就是在`values[0]和values[1]`取最大值，如果values[0]>values[i]，那么我们就决定`不取i=1`这个元素，反之`取i=1`；--> 把这个结果存在dp[2]上；
> 1. 如果有三个房子，你又该怎么计算呢？当你迭代到`i=2`这个位置上（values数列里的第三个元素），你怎么判断能抢到的最大价值呢？三个元素似乎就有点复杂了，比如说例子中的前三个元素`[10,1,9]`，决定用不用`i=2`这个位置上的元素，要看`dp[1]+这个元素值`和`dp[2]`的大小关系，dp[3]的值应该是他们俩个中取max；
> 1. 你找出规律了没？其实算dp[i]的值，只需要比较`dp[i-2]+values[i-1]`和`dp[i-1]`的大小关系。
>
> 到这里，我们就有答案了，你有点感觉了没？这就是`取`或者`不取`在每个value上的应用。


### 背包问题里的`放入背包`或者`不放入背包`

### 每个value上依旧是两个选择，但是两个选择可能因为之前转态不同而不同
> 我们来尝试这道题[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)来解释里面的`取`或者`不取`思想。这题的详细解释请看[这篇帖子](./coding/dp/stock.md)。这里重点讲讲`取`或者`不取`思想。
> 
> 假设股票的价格是这样的`prices = [7,1,5,3,6,4]`；我用1表示持有股票，0表示不持有股票；
> 1. 假设在第`-1`天，也就是说股市还没开始，那么不持有股票的状态应该是这样的`dp[-1][0]=0`,这个很容易理解吧？股市没开始，**利润肯定为零**。
> 1. 那么在第`-1`天（股市还没开始）持有股票的利润是多少呢？理论上这个状况是不可能出现的，但是为了方便计算，我们应该赋一个值：`dp[-1][1]=-infinity`,因为要求最大利润吗，所以当股市没开始时有股票的不可能情况就赋一个最小值吧：**利润为负无穷**。
> 1. 时间来到第`0`天，也就是说股市开始的第一天，那么今天不持有股票的状态应该是这样的`dp[0][0]=max(昨天就不持有dp[-1][0]，昨天持有今天卖dp[-1][1]+prices[i])`；类似的，今天持有股票的状态应该是这样的`dp[0][1]=max(昨天就不持有dp[-1][1]，昨天不持有今天买dp[-1][0]-prices[i])`；所以在股市开始的第一天，dp的最佳状态是这样的：`dp[0][0]=max(0, -infinity+prices[0])=0`, `dp[0][1]=max(-infinity, 0-prices[0])=-7`；
> 1. 你感受到了吗？这里的`不取`显然就是不买也不卖，而`取有两种取法`，一种是买，另一种是卖。所以我们要在遍历过程中维护两种不同类型的`取`或者`不取`选择；
>
> 你大脑里能否展现出如下迭代结果：`[[0, -INF], [0,-7],[0,-1],[4,-1],[4,-1],[5,-1],[5,-1]]`，答案就是dp[n-1][0]，aka最后一天不持有股票，所以答案是5；今天的最佳状态，至于昨天的最佳状态相关；

### 坐标型问题里的`选一个`或者`选两个`的选择
> 关于这道题[746. 使用最小花费爬楼梯](https://leetcode.com/problems/min-cost-climbing-stairs/)，这里`取`或者`不取`的思想对应的是`迈一凳`或者`迈两凳`的选择，但实际上也是针对每个当前状态，对于它之前的两个状态进行`取`或者`不取`的选择。
>
> 比如说给你一个`costs = [2,1,5,3,6,4]`，因为原题告诉你可以从第一凳开始，也可以从第二凳开始，并且你可以一下迈一凳或者迈两凳。那就初始化`dp[0] = cost[0]`和`dp[1] = cost[1]`。这样吧，当你看怎么最少的到达第三凳时，你其实是对第一凳和第二凳进行`取`或者`不取`的选择，哪个小`取`哪个。这是典型的坐标型动规思维，其实里面也运用了这种`取`或者`不取`的思维。
>
```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n= cost.length;
        int[] dp = new int[n];
        dp[0] = cost[0];
        dp[1] = cost[1];

        for(int i=2; i<n; i++){
            dp[i] = Math.min(dp[i-1], dp[i-2])+cost[i];
        }

        return Math.min(dp[n-2],dp[n-1]);
    }
}
```

### 博弈问题里的`选一个`或者`选两个`的选择
> 博弈类动规的经典题[领扣394. 硬币排成线](https://www.lintcode.com/problem/394/)，看先手能不能拿到最后一枚硬币。这里`取`或者`不取`的思想对应的是`选一个`或者`选两个`的选择，也是二维的选择，所以思路上有点类似。
>