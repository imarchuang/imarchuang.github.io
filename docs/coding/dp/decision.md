# 决策类动规题型概论

### **敲黑板** 关于决策类动规的思考
> 决策，英文是Decsion Making，其实对当前元素取或者不取的决策。说到这里，你想的没错，背包类knapsack问题其实都是这类问题。不过从深层意义上来说，其实不止背包类动规是这个思想，其实所有子序类动规都是这种决策思想的应用，因为子序的决策就是在每个元素上做`跳或者不跳`的决策，而且博弈类的动规里，很多很多的题目也是基于这种思维的。下面举几个例子让你体会一下这种`取或不取`的妙处：
> 1. 爬楼梯题目I：给你n凳楼梯，你每次可以爬一凳，也可以爬两凳，问你从第0凳开始爬，到达第n凳的方法有几种。因为你有爬一凳还是爬两凳的选择，这决定了每一凳楼梯都有被跳过的可能，这个能理解吗？比如说一共3凳楼梯，你可以选择一凳一凳的走三步，也可以先爬两凳然后再爬一凳，当然也可以先爬一凳再爬两凳，这就一共有三种到达第三凳爬法。这个过程中第一凳或者第二凳是可能在某种爬法里被跳过的对不对？从状态转换方程上来说，那就是当年想到达第i凳的时候，它其实让你求爬到第i-1凳和爬到第i-2凳的方法数之和（因为只有从第i-2凳迈两步到达第i凳或者从第i-1凳迈一步到达第i凳这两种可能）。所以你可以得出`dp[i] = dp[i-1] + dp[i-2]`;
> 1. 爬楼梯题目II[746. 使用最小花费爬楼梯](https://leetcode.com/problems/min-cost-climbing-stairs/)：还是给你n凳楼梯，你也是每次可以爬一凳，也可以爬两凳，但是这回你每到达一凳台阶，你就会被扣掉一些分数。而且这次你可以从第1凳开始爬，也可以从第2凳开始爬，那么问题就是：如果到达第n+1凳（第n凳上面的楼顶），你最少要被扣掉多少分？思路和上一题基本上一模一样：
>       * 你有爬一凳还是爬两凳的选择，这决定了每一凳楼梯都有被跳过的可能，也就是这题转化成了找出一个子序列是这个子序列的和是最小的。比如说每凳要被扣得分数是这么一个数组`[10， 15， 20]`，让你到达到楼顶（第4凳），你怎么走扣掉的分数最小？用肉眼撒摸一下，你可能发现我从第二凳开始一下迈两步达到楼顶只被扣15分是最小的。现在，从子序类动规的状态转换方程上来说，那就是当年想到达第i凳的时候，你其实要看看爬到第i-1凳和爬到第i-2凳的被扣得分数那个比较小对吧？（因为只有从第i-2凳迈两步到达第i凳或者从第i-1凳迈一步到达第i凳这两种可能，所以要选被扣得分数少的）。所以你可以得出`dp[i] = Math.min(dp[i-1],dp[i-2])+points[i]`;
> 1. 解码方法I：题目是这样的：一条包含字母 A-Z 的消息通过以下映射进行了**编码**，比如说`'A' -> "1"`，`'B' -> "2"`，...，`'Z' -> "26"`，现在给出你一个数字字符串，比如说“226”，让你求这个数字编码一共有几种**解码方法**。还是那这个例子，“226”可以表示`BBF(2,2,6)`，也可以表示`VF(22,6)`，还可以表示`BZ(2,26)`。讲到这儿聪明的你应该想到了给之前爬楼梯跳一凳还是跳两凳是不是特别相似？只不过，这次你是选择跳一凳还是跳两凳是有限制条件的，因为如果选择你跳两凳，有可能数值超过了26，这说明你是不能这么跳的。还有一个限制就是，如果你选择跳一凳，结果这凳的值是“0”，说明你也是不能这么跳的。到这里了，你能否可以得出这个状态转化方程？`dp[i] += dp[i-1](如果不是“0”)并且 dp[i] += dp[i-2](如果s.substring(i-2,i)的值是在[10,26]区间里)`;
> 1. Word Break I：上一个题目是在跳一凳还是跳两凳的选择过程中加了额外限制，现在这个例子Word Break那就可以说加了更多额外限制，这次不让你跳一凳还是跳两凳了，这题是说你能跳几凳是取决于你跳过的这些元素能否组成一个合法的单词。比如说给你了一个单词集合`['cat','cats','and','sand','dog']`,然后再给你一个字符串`s="catsanddog"`，现在要你求出这个字符串`s="catsanddog"`能否切分成单词集合里的单词组合。这个乍一看似乎并没有那么明显的属于子序类动规题，但是你仔细琢磨琢磨就发现，这个很像某些手游里的吃金币设计环节，比如说有些金币吃了可以让你跳3步，有些吃了可以让你跳5步，这里的金币就是单词集合里的那些单词，你只要match到其中一个，你就相当于吃了金币可以合法的跳了。比如说，假设我现在处在第0个位置上，我可以吃一个`"cat"`金币跳到`‘t’`这个位子上，也可以吃一个`"cats"`金币跳到`‘s’`这个位子上；类似的，假设我现在处在`‘t’`这个位子上，我可以再吃一个`"and"`金币跳到`‘d’`这个位子上，然后接着再吃一个`"dog"`金币跳到`‘g’`这个位子上;讲到这儿，聪明如你是否可以理解这是一个子序类动规问题了？你能否可以得出这个状态转化方程？`dp[i]=dp[j]&&wordDict.contains(s.substring(j,i)`，这里j是指上次能跳的位置，你可以这样穷举j -> `0...i-1`;
> 1. 打家窃舍I：上一个word break题目涉及了吃金币决定跳几凳的限制，这次我们再来看看在**跳凳**过程中的其他限制方式；这题核心和跳凳是没区别的，只不过爬楼梯的时候你只有跳一凳还是跳两凳的选择，但是这个**打家窃舍**的跳凳过程其实也是类似于跳一凳还是跳两凳的选择，因为你琢磨一下，到第i天的时候，你其实有两个选择，选择1是`今天不抢`，这就意味着你的收益是**继承昨天**来的；选择2是`今天抢`，这就意味着你的收益是**继承前天**来的；到这里了，你可能会问，为什么不能是**继承大前天或者大大前天**呢？这题的巧妙之处就在于每个房子里的价值都是**非负整数**，这样就说每次不抢的连续房子不会超过两个。还不理解吗？举个例子：假设房子里价值数组是这样的`[1,3,2,1,100,1,1,10]`，聪明的你肯定会这么抢房子：[**1**,3,**2**,1,**100**,1,1,**10**]；那如果房子里价值数组是这样的`[1,3,2,1,100,1,1,1，10]`呢？聪明的你肯定会这么抢房子：[**1**,3,**2**,1,**100**,1,**1**,1,**10**]对吧？你肯定不会把那个3个连续的1一起跳了吧？所以呢这题的状态转化方程就是这样的`dp[i]=Math.max(dp[i-1], dp[i-2]+nums[i-1]`，这里注意索引偏移; 
>       * 这里留给你一个思考题，如果房子的价值有可能是负数呢？这种情况下你会怎么做？
>       * 阅读[这里](#打家窃舍I)加深你的理解；
> 1. 买卖股票的最佳时间I：上一个打家劫舍题目涉及了每天都有两种选择，那就是`抢或者不抢`。其实那道题里，如果是可以用一个二维dp数组`dp[n+1][2]`来解答的，用1表示抢，0表示不抢；那么状态转移方程可以这么写：`dp[i][0]=Math.max(dp[i-0][0], dp[i-1][1])`(就是说第i天没抢的可能性有两种：一是第i-1天也没抢，二是第i-1天抢了，二者取其大)和`dp[i][1]=nums[i-1]+dp[i-1][0])`(就是说第i天要抢的话，肯定是说第i-1没抢)；举个例子进一步说明一下：假设房子里的价值是这样的`[10,1,9,19,9,7]`，也么根据状态转移方程我们可以得出这个结果数组：`[[0,0],[0,10],[10,1],[10,19],[19,29],[29,28],[29,36]]`，然后答案就是`Math.max(29, 36)`; 你脑子里能否一步步的闪出这个二维状态数组？如果你可以，恭喜你，你已经理解什么叫做**状态机**了。这个买股票的题，也是利用这种所谓的状态机思维，假设股票的价格是这样的`prices = [7,1,5,3,6,4]`，用1表示持有股票，0表示不持有股票；那么状态转移方程可以这么写：
>       * 第i天不持有股票的状态：`dp[i][0]=max(昨天就不持有dp[i-1][0]，昨天持有今天卖dp[i-1][1]+prices[i])`；
>       * 类似的，第i天持有股票的状态应该是这样的`dp[i][1]=max(昨天就不持有dp[i-1][1]，昨天不持有今天买dp[i-1][0]-prices[i])`；
>       * 你脑子里能否一步步的闪出这个二维状态数组`[[0, -INF], [0,-7],[0,-1],[4,-1],[4,-1],[5,-1],[5,-1]]`？答案就是dp[n][0]，aka最后一天不持有股票，所以答案是5。这里还有一个重点要解释一下，那就是base case初始状态：
>       * 假设在第`-1`天，也就是说股市还没开始，那么不持有股票的状态应该是这样的`dp[-1][0]=0`,这个很容易理解吧？股市没开始，**利润肯定为零**。
>       * 那么在第`-1`天（股市还没开始）持有股票的利润是多少呢？理论上这个状况是不可能出现的，但是为了方便计算，我们应该赋一个值：`dp[-1][1]=-infinity`,因为要求最大利润吗，所以当股市没开始时有股票的不可能情况就赋一个最小值吧：**利润为负无穷**。
>       * 小结一下就是，这里不只看能跳几凳了，而是跳的过程中要保持两种(买和卖)不同状态下的最优解；
>       * 阅读[这里](#买卖股票最佳时间)加深你的理解；
> 1. 给你一个数组`[10,11,1,2,3,4]`，让你找出最长的**strickly increasing subsequence**的最长个数，这就是经典的LIS最长子序列题目。这个问题是咋个决策法呢？
>
> 问题描述多数是张这个样子的：`Given a set of values`, `find an answer with an option to chooose or ignore the current value`；
>
> 这类题的一个很重要思想就是，你通常有两个选择：`取`或者`不取`，这样你就要在这两种选择找最优的一种。不过再**说一点**，就是这个每个value上的两种选择可能会有限制，我会在股票买卖的问题系列里展示这个限制；
>

### 打家窃舍I
> 先来看看经典的问题[198. 打家劫舍]()，这个问题的一个关键特性是每个房子里的都有**正数**的价值，然后题解要求抢最大值得价值，所以每抢一个房子，对答案肯定是增加价值的。假设房子的价值是这个数列`[10,1,9,19,9,7]`，我们用脑回路过一下这个`取`或者`不取`思想；
> 1. 如果没有任何房子，那能抢到的最大价值一定是`0`；--> 把这个结果存在dp[0]上；
> 1. 如果只有一个房子，那能抢到的最大价值一定是那个唯一房子里的价值`values[i]`；--> 把这个结果存在dp[1]上；
> 1. 如果有两个房子，你该怎么计算呢？当你迭代到`i=1`这个位置上（values数列里的第二个元素），你怎么判断能抢到的最大价值呢？两个元素似乎也是直截了当，就是在`values[0]和values[1]`取最大值，如果values[0]>values[1]，那么我们就决定`不取i=1`这个元素，反之`取i=1`；--> 把这个结果存在dp[2]上；
> 1. 如果有三个房子，你又该怎么计算呢？当你迭代到`i=2`这个位置上（values数列里的第三个元素），你怎么判断能抢到的最大价值呢？三个元素似乎就有点复杂了，比如说例子中的前三个元素`[10,1,9]`，决定用不用`i=2`这个位置上的元素，要看`dp[1]+这个元素值`和`dp[2]`的大小关系，dp[3]的值应该是他们俩个中取max；
> 1. 你找出规律了没？其实算dp[i]的值，只需要比较`dp[i-2]+values[i-1]`和`dp[i-1]`的大小关系。
>
> 到这里，我们就有答案了，你有点感觉了没？这就是`取`或者`不取`在每个value上的应用。


### 背包问题里的`放入背包`或者`不放入背包`

### 买卖股票最佳时间
> 我们来尝试这道题[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)来解释里面的`取`或者`不取`思想。这题的详细解释请看[这篇帖子](./coding/dp/stock.md)。这里重点讲讲`取`或者`不取`思想。
> 
> 假设股票的价格是这样的`prices = [7,1,5,3,6,4]`；我用1表示持有股票，0表示不持有股票；
> 1. 假设在第`-1`天，也就是说股市还没开始，那么不持有股票的状态应该是这样的`dp[-1][0]=0`,这个很容易理解吧？股市没开始，**利润肯定为零**。
> 1. 那么在第`-1`天（股市还没开始）持有股票的利润是多少呢？理论上这个状况是不可能出现的，但是为了方便计算，我们应该赋一个值：`dp[-1][1]=-infinity`,因为要求最大利润吗，所以当股市没开始时有股票的不可能情况就赋一个最小值吧：**利润为负无穷**。
> 1. 时间来到第`0`天，也就是说股市开始的第一天，那么今天不持有股票的状态应该是这样的`dp[0][0]=max(昨天就不持有dp[-1][0]，昨天持有今天卖dp[-1][1]+prices[i])`；类似的，今天持有股票的状态应该是这样的`dp[0][1]=max(昨天就不持有dp[-1][1]，昨天不持有今天买dp[-1][0]-prices[i])`；所以在股市开始的第一天，dp的最佳状态是这样的：`dp[0][0]=max(0, -infinity+prices[0])=0`, `dp[0][1]=max(-infinity, 0-prices[0])=-7`；
> 1. 你感受到了吗？这里的`不取`显然就是不买也不卖，而`取有两种取法`，一种是买，另一种是卖。所以我们要在遍历过程中维护两种不同类型的`取`或者`不取`选择；
>
> 你大脑里能否展现出如下迭代结果：`[[0, -INF], [0,-7],[0,-1],[4,-1],[4,-1],[5,-1],[5,-1]]`，答案就是dp[n][0]，aka最后一天不持有股票，所以答案是5；今天的最佳状态，至于昨天的最佳状态相关；

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n= cost.length;
        int[] dp = new int[n];
        dp[0] = cost[0];
        dp[1] = cost[1];

        for(int i=2; i<n; i++){
            dp[i] = Math.min(dp[i-1], dp[i-2])+cost[i];
        }

        return Math.min(dp[n-2],dp[n-1]);
    }
}
```

### 博弈问题里的`选一个`或者`选两个`的选择
> 博弈类动规的经典题[领扣394. 硬币排成线](https://www.lintcode.com/problem/394/)，看先手能不能拿到最后一枚硬币。这里`取`或者`不取`的思想对应的是`选一个`或者`选两个`的选择，也是二维的选择，所以思路上有点类似。
>