# 经验型动规

**刷到了一些题，背后的数学理论证明着实高深，所以在无法提供数学证明的状态下，我感觉把他们暂且归类为经验型吧**

?> 这篇帖子里的题多数算是比较难的，面试中如果遇到的话只能诚实的跟面试官说自己无法提供数学证明，但是根据**常识common sense**这种思路应该是可以的。

### **刷题列表**
1. [651. 四键键盘（中等）](#四键键盘) 
1. [818. 赛车](#赛车) https://leetcode.com/problems/race-car/
1. [887. 鸡蛋掉落](#鸡蛋掉落) https://leetcode.com/problems/super-egg-drop/

### 四键键盘
[651. 四键键盘（中等）](https://www.lintcode.com/problem/867/) 

![](../pictures/dp/sub10.png)

?> **[思路]** 这题是一个具有很强技巧性的问题。首先，看道题，几乎很快能确认是个动规问题，一是因为在遍历每个第i个键时你明确有四个选择，其次是这题要求求最值。照着这个思路，先思考一下这动规题的状态吧。其实有三个变量是**状态**，按键i次后屏幕上已显示的输出的A的数量`a_num`，还剩余的按键次数`N-i`次，粘贴板上的缓存`copy`，既然每步都有四个选择，那就遍历这三个变量然后择优呗。这其实就是暴力动规算法的雏形。只不过这个暴力动规算法过不了leetcode，即使你用memo记忆化搜索也过不了。然后就继续深入思考一下，其实这题的答案肯定是这样的，当N比较小时候，就直接`按A键`，直到N比较大是再按这个规律去按键：`Ctrl-A，Ctrl-C，Ctrl-V，Ctrl-V，Ctrl-V...` 既然是这样，那怎么如果你已经知道了前`i-1`次操作能得到的最大输出A的数量，你能导出第i次操作的输出A最大值吗？答案是能的，又是高中学的数学归纳法(mathmatical induction)，你只要留出两步操作给`Ctrl-A，Ctrl-C`，剩下的就一直`Ctrl-V，Ctrl-V，Ctrl-V...`。好了，那么`Ctrl-V`时粘贴板上的最大值是多少呢？这个不一定是最后一个dp[i-3]哟，举个例子，当`N=7`时，dp[3]的值应该是4，就是说屏幕上输出是`AAAA`，然后最后3个操作可以留给复制粘贴操作，最后屏幕上输出是8个A`AAAAAAAA`，也就是说dp[6]是**8**. 实际上dp[6]最优解应该是**9**，怎么做到的呢？因为`dp[2]=3`，这时候你将剩余的4个操作进行`选择``复制``粘贴``粘贴`，这样就可以粘贴两次最后屏幕上输出是`AAAAAAAAA`（9个A）。既然不能直接用dp[i-3]，那么就遍历所有之前的i-1个`dp[j]`就好了；这个`j`要从哪儿开始遍历呢？答案是**2**，因为需要留两步操作给`Ctrl-A，Ctrl-C`，你就可以这么写了：`for(int j=2; j<i; j++)`，要注意哟，你现在站在`第i个`操作键上，而你遍历的是前`i-1`个键，所以你需要看的是`dp[j-2]`的值，然后一直粘贴粘贴粘贴... 现在回头想想，其实解题思路跟[最长递增子序](#最长递增子序)题差不多，都用了数学归纳法。

```java
public class Solution {
    /**
     * @param N: an integer
     * @return: return an integer
     */
    public int maxA(int N) {
      int[] dp = new int[N];
      dp[0]=1;
      for(int i=1; i<N; i++) {
        dp[i] = dp[i-1]+1; //选择按A键，cover N比较小的状况
        for(int j=2; j<i; j++){
          // 全选 & 复制 dp[j-2]，连续粘贴 i - j 次
          // 屏幕上共 dp[j - 2] * (i - j + 1) 个 A
          dp[i] = Math.max(dp[i], dp[j - 2] * (i - j + 1));
        }
      }
      return dp[N-1];
    }
}
```
