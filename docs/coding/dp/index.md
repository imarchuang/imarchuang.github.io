# 动态规划纲领

1. [何为动规](#何为动规) 
1. [九章动规模板](#九章动规模板) 
#### 知识要点.
- [坐标型动规](./coding/dp/indices.md) 
- [子序类动规](./coding/dp/subsequence.md) 
- [背包类动规](./coding/dp/knapsack.md) 
- [博弈类动规](./coding/dp/gametheory.md) 
- [区间型动规](./coding/dp/interval.md)
- [股票买卖系列](./coding/dp/stock.md)
- [不知道哪一类](./coding/dp/unknown.md)

### **何为动规**
**听说动规，这类题确实挺玄学，我刷到今天了(2022.03.15)了，依旧觉得有些题目拿来，知道是动规题，但是对状态转移方程依旧是存在于某种程度的运气。玄学的东西，需要的刷到一定量的题了，然后温故而知新，不定时总结感悟刷过的题，顿悟的过程是很痛苦的。**

**这里提一下记忆化搜索和动规。从本质上讲，这两个是完全一个东西，都是对最优子结构问题处理方式。记忆化搜索是自顶而下的一种思维，而传统的动态规划则是一种自底向上的思维方式。具体到解题上，我个人通常是先试着记忆化搜索的思路，如果在思索过程中能够很快地转变成自底向上的思维方式，就用动规写法。不是每道题都能将记忆化搜索转化成动规思维，尤其是题中的起点或者终点不容易确定的时候**

从算法本质的连接上来说，`二叉树的分治` --> `分治深搜` --> `记忆化搜索` --> `动态规划`。但是别被这些看似高大上的文学词汇迷惑了，其实不外乎多刷题，看能不能最短时间里瞅出一下几个特性：
1. 肯定需要`穷举`，但是暴力穷举多数是多项式级别时间复杂度(O(2^n), O(n!)等)；
1. 问题存在 **`重复子问题`** ，这个其实通过一段时间的锻炼，是很容易看出来的；
1. 细化问题的**拆解**，把问题能够拆解成具备 **`最优子结构`** 的N个子问题。这里提到了一个`dp函数的定义`问题，一个比较好的路子就是照着原题的语义思考，能定义出dp函数是基础，找到 **`状态转移方程`** 就是一个玄学问题了。说到**照着原题的语义思考**，其实这个思路在遇到背包问题的时候就不太实用了，因为`背包问题的难点`就是在于怎么把问题转化成一个背包问题。
1. 最后，在解动规问题过程中，还有一项挺考验一个人的基本功，那就是找 **`base case`** ，这个呢也没啥通用规则，就是题刷多了自然能随机应变；

>**今天了(2022.07.03)了，我似乎感觉动规已经没有那么玄学**，这里我试图再继续总结一下对于动规的感受。
>1. 动规题三要素是**重复子问题**、**最优子结构**、**状态转化方程**。
>1. 关于**重复子问题**，其中隐含的的一层意思就是问题是可以切小成N个**子问题**的，这里的切分遵循的就是**分而治之**的思想，这个思路我们在很多地方都提过，比如说归并排序啊，括号生产啊，切分链表，切分字符串等等的地方都提过这个思想，现在再试着套上这个**分而治之**的思想在一道动规题上。给你一串硬币面值，比如说`[1,2,5]`，然后输入一个金额`amount`，返回凑出`amount`的**最少硬币个数**。这个问题能不能切成很多的更小的**子问题**？可以的，假设存在一个函数`fn(amount)`，那么求`fn(7)`其实就等于`1+取最优(fn(7-1),fn(7-2),fn(7-5))`，这个减法的过程中问题会越来越小；那么咋么知道是**重复**子问题的呢？你其实一眼就能瞅出来，比如说`f(2)`可以是`fn(7-5)`，也可以是`fn(4-2)`，或者可以是`fn(3-1)`，这里你发现了有多条路径可以到达`f(2)`，所以这里是一定存在**重复子问题**的。
>1. 关于**最优子结构**，首先说明一下，这种性质并不是动态规划问题专有的。举个例子，比如说让你搜索一个二叉树中的最大值，这里存不存在**最优子结构**呢？答案是肯定的，假设左子树最大值是`leftMax`，右子树最大值是`rightMax`，那么整个数的最大值不就是`max(root.val, leftMax, rightMax)`吗？这里以root为根的树的最大值可以通过左右子树推导出来，所以是符合最优子结构的对吧？但是这题并非动规题。回到硬币问题，你想求`amount = 11`时的最少硬币数，如果你知道凑出`amount=[10, 9, 6]`的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为`[1, 2, 5]`的硬币），求个最小值，就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是**互相独立**的。你回头来想想自底而上的dp数组动规解法，它核心不就是从最简单的base case往后推到吗？你可以可以想象成一个链式反应，**以小博大**。但只有符合最优子结构的问题，才有发生这种链式反应的性质。到这儿你回过神来来了吗？动规题因为一定需要存在**最优子结构**，所以动规的题基本上都是求最值得问题。找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则`OK`。
>1. 最后来说说动规里最难的部分**状态转化方程**。因为式方程嘛，肯定需要存在自变量对吧，比如说`x`，`y`之类的，也就是说可以是一元的，也可以是多元的，这里的**状态State**的概念指的就是那些个自变量。回到硬币问题，在**原问题和子问题中会变化的变量**的东西是啥？硬币数量无限，硬币的面额也是题目给定的，所以这两个参数算作常数，是不变的，只有目标金额会不断地**向base case靠近**，所以惟一的**状态**就是目标金额`amount`，找到这个合适的自变量，我觉得就成功了一大半，因为你接下来所需要做的就是**遍历这(些)个自变量**所有可能的值直到**base case**，而且就我刷题经验而言，我负责的告诉你这个**遍历的颗粒度**通常都是整数的，所以你的脑子里这时应该呈现一个`dp数组`，有几个自变量，这个`dp数组`就是几维！有了dp数组呢，又大致有了**遍历颗粒度**，你现在需要确认的就是**什么会导致这(些)个`状态`产生变化？**这些导致状态变化的行为，就是所谓的**选择**，这个跟我们暴力回溯算法或者分治算法中的`选择`是一回事儿，**说白了就是在你切分原问题成子问题过程中，你脑子里所能呈现的抉择多叉树**。
>
我会针对5大类面试中常考的动规题型分别进行总结，但是进入那里之前，我在啰嗦几句。在刷二叉树的时候，我们遇到过这个问题 [96. 不同的二叉搜索树（简单)](https://leetcode.com/problems/unique-binary-search-trees/)，温故而知新嘛，就用这个问题来总结一下动规。
![](../pictures/dp/1.png)
这题吧，好的不得了，因为这不是纯找数列规律题嘛。文学上来说这题属于子序类动规。先别管那么高大上的词汇，先来温习一下高中数学吧。我们先定义两个函数：
1. **`dp(n)`**: 是说给一数列[1...n]，能得到多少个二叉搜索树；
1. **`f(i,n) & 1<=i<=n`** ：以数字i为根，能得到多少个二叉搜索树；
1. 通过以上两个函数，我们不难发现其实主要是对`f(i,n)`中的i和n进行合理的遍历，这两变量就是所谓的`状态`；
1. 动规的问题中，其实还有一块要注意，就是所谓的`选择`。这里选择比较明确，就是将(i,n)两变量按照每步为1的节奏遍历，以穷举完 **`1<=i<=n`** ；
1. 上边两个函数的关系就是：`dp(n) = f(1, n) + f(2, n) + ... + f(n, n)`;这就是所谓的`状态转移方程`；
1. 动规问题都是穷举嘛，但是穷举必须有出口啊。这就是所谓的`base case`，这里的base case是dp(0)=1，dp(1)=1；

```js
var numTrees = function(n) {
    let dp = Array(n+1).fill(0);
    //base case
    dp[0] = 1;
    dp[1] = 1;
    dp[2] = 2;
    for(let i=3; i<n+1; i++){
        for(let j=1; j<=i; j++){
            dp[i] += dp[j-1] * dp[i-j];
        }
    }
    return dp[n];
};
```

我温故温上瘾了，再来一个例子来展示一下所谓`动态`规划的思维。看看这题[131. 分割回文串（中等)](https://leetcode.com/problems/palindrome-partitioning/)

![](../pictures/dp/2.png)
这题吧，我不想展示整题的解法，而是想提一下判断字符子串是否为回文的一个写法。

回文串的问题在leetcode上有好几个，但是所有回文串题的解法都遵循一个原则：**由中间向两边扩散**。来借这题剖析一下回文：
1. **由中间向两边扩散** 分别用两个指针(i,j)表示左右，这两变量(i,j)就是所谓的`状态`；
1. 所谓的`选择`嘛，这里很容易理解：就是让遍历完所有i和j，以穷举 **`0<=i<=n` && `0<=j<=n`** n为字符串长度；
1. 所谓`状态转移方程`吧，很巧妙，就是：`当s.charAt(i)==s.charAt(j)时，dp(i，j)= dp(i+1，j-1)`，否则就一定不是回文串；
1. 最后说是`base case`：当i==j时候，dp（i，j）== true这个好理解，因为单个字符一定是回文串，当i>j时候，dp（i，j）== true这个怎么理解呢？i>j时，说明子串是个空字串，空字串也是回文串！

> **敲黑板** 这里展示一下怎么以动规的方式写一个字符串里回文子串的位置：
  a b a b d
a T F T F F
b T T T F F
a T T T F F
b T T T T F
d T T T T T  

```js
const getIsPalindrom = (s) => {
    let n = s.length;
    let dp = [...Array(n)].map(x=>Array(n).fill(true));
    for(let i=n-2; i>=0; i--){
        for(let j=i+1; j<n; j++){
            if(i<j){
                if(s.charAt(i)==s.charAt(j)){
                    dp[i][j] = dp[i+1][j-1]; 
                } else {
                    dp[i][j] = false;
                }
                    
            } 
        }
    }
    
    return dp;
    
}
```
```java
public boolean[][] getIsPalindrom(String s) {
    int n = s.length();
    boolean[][] dp = new boolean[n][n];
    for (boolean[] row: dp)
        Arrays.fill(row, true);
    
    for(int i=n-2; i>=0; i--){
        for(int j=i+1; j<n; j++){
            if(i<j){
                if(s.charAt(i)==s.charAt(j)){
                    dp[i][j] = dp[i+1][j-1]; 
                } else {
                    dp[i][j] = false;
                }
                    
            } 
        }
    }
    
    return dp;
    
}
```

### 九章动规模板
> 使用场景：
> 1. 求方案总数(90%) 
> 1. 求最值(80%) 
> 1. 求可行性(80%) 

> 不适用场景：
> 1. 求所有具体方案(99%) 
> 1. 输入数据无序(背包问题除外，60-70%) 
> 1. 暴力算法已经是多项式时间复杂度(80%) 

> 动规四要素(对比递归四要素)
> 1. 状态State <--> 递归的定义
> 1. 状态转化方程Function <--> 递归的拆解
> 1. base case初始化 <--> 递归的出口
> 1. 答案Answer <--> 递归的调用

> 复杂度
> 1. 时间复杂度: `O(状态总数 * 每个状态的处理耗费)`，等于`O(状态总数 * 决策数)`
> 1. 空间复杂度: `O(状态总数)` 如果不适应滚动数组；如果使用滚动数组优化, n 是被滚动掉的那一个维度，就是`O(状态总数 / n)`



https://www.zhihu.com/question/291280715/answer/1007691283
https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns