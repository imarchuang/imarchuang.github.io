# 子序概论

#### **敲黑板** 关于子序列的思考
> 子序列(subsequence)的定义：子序列是一个集合里元素的组合，这个组合里的元素之间的前后相对位置要维持的其在原集合里的原序。比如说，`abbacd`这个字符集合，`abd`是其一种子序列，但是`adb`就不是其子序列。它于子串/子数组的核心区别就是子序列的元素可以是不连续的，`abd`和`adb`都不是`abbacd`这个字符集合子串，而`abb`就是其子串。所以从数学意义上说，子串/子数组时间上是子序列的一个子集概念。
>
> 子序列问题贯穿所有题型，从纯粹找所有子序列，到子序列的动规问题。因为其**遵循原序**的特殊性，因此在其穷举遍历的方法选择上，通常会更具有技巧性，而且通常会涉及到`动规`的一些遍历手法；
>
> 纯穷举子序列问题，其bigO肯定是O(2^n)；涉及到子序列的时候呢，用动规的遍历技巧通常能达到O(n^2)；
>

#### **敲黑板** 子序列的实例
> 给你一个集合，比如说[1,2,3]，它的子集通常以几种形式呢？
> 1. 所有的子数组：[], [1], [1,2], [1,2,3], [2], [2,3], [3]，因为子数组一定是连续的元素；
> 1. 所有的子序列/子集：[], [1], [1,2], [1,2,3], [2], [2,3], [3], **[1,3]**，因为子序列是可以不连续的元素组成的；
>
> 这里子序列的问题是个O(2^n)的时间复杂度问题，我们看看用java的话怎么写出来：
```java
//写个数学版本的
public List<List<Integer>> getAllSubSequence(int[] nums) {
    List<List<Integer>> res =  new ArrayList<>();
    int count=1<<nums.length; //eg,如果n=3，那么count = 2^3 = 8
    for(int mark=0; mark<count; mark++) {
        List<Integer> temp = new ArrayList<>();
        for(int i=0; i<nums.length; i++){
            if(((1<<i)&mark)!=0)){ //说明nums里第i位置的元素被选中进子集
                temp.add(nums[i]);
            }
        }
        result.add(temp);
    }

    return temp;
}
```
以上数学解法怎么理解呢？
1. 长度为n的数组一共还有2^n-1个子序列；
1. 我们可以这么理解，子序列就是在原序列上取的，那么原序列被取到的话就是1，否则为0.

例如原序列`[1 2 3]`，子序列是2，那么抽象的结果就是`[0 1 0]`；子序列是 1 3 ，抽象这是`[1 0 1]`；这最大的优点就是可以用二进制来表示，以下表格可以帮助你更好的理解这个做法。假设我们用nums={1,2,3}这里例子: 下面表格的横向栏位可以用`1<<i`来模拟，比如说001就是`1<<0`结果的二进制表示，010就是`1<<1`结果的二进制表示，100就是`1<<2`结果的二进制表示；至于纵向的行数就更容易理解了，其实就是个计数器`[0...n]`的二进制表示。`(1<<i)&mark)!=0`就很容易判断矩阵里坐标位置的nums[i]是否放进集合。


| &计算结果 | 001   | 010    | 100    |
| -------- |:-----:| :-----:| :-----:|
| 000      | 0     | 0      | 0      |
| 001      | 1     | 0      | 0      |
| 010      | 0     | 1      | 0      |
| 011      | 1     | 1      | 0      |
| 100      | 0     | 0      | 1      |
| 101      | 1     | 0      | 1      |
| 110      | 0     | 1      | 0      |
| 111      | 1     | 1      | 1      |

以上解法更侧重数学思维，不过这题其实是个经典的回溯框架应用问题：
```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        backtrack(path, nums, 0, result);
		return result;
    }
    
    private void backtrack(List<Integer> path, int[] nums, int startIndex, List<List<Integer>> result){
        result.add(new ArrayList<>(path));
        
        for(int i=startIndex; i<nums.length; i++){
            path.add(nums[i]);
            backtrack(path, nums, i+1, result);
            path.remove(path.size()-1);
        }
    }
}
```

> 我们说过了子序、子集问题的时间复杂度其实是O(2^n)，是指数级的。那么有没有一个更快的算法让我们判断某个组合是不是一个集合的子集呢？请看这题[领扣1263. 是子序列吗？](https://www.lintcode.com/problem/1263/)作为例子。
>
> 例如，给出一个字符串`abbacd`，我么能不能快速的判断`aac`是它的子序，而`bdc`不是它的子序呢？这题的暴力解法就是把字符串的所有子序列都找出来()，然后看有没有包含原题给出的。其实稍微想一下就知道一个优化办法就是：给出一个`startIndex`，就是看找到某个字符c在这个`startIndex`之后出现的第一个位置。
```java
public class Solution {
    /**
     * @param s: the given string s
     * @param t: the given string t
     * @return: check if s is subsequence of t
     */
    public boolean isSubsequence(String s, String t) {
        // Write your code here
        int start = -1;
        for(char c : s.toCharArray()){
            start = isExist(c, t, start);
            if(start==-1) return false;
        }

        return true;
    }

    private int isExist(char c, String t, int startIndex){
        for(int i=startIndex+1; i<t.length();i++){
            if(c == t.charAt(i)){
                return i;
            }
        }

        return -1;
    }
}
```
> 这题的followup也很巧妙：如果输入包含很多`S`串，例如为`[S1, S2, ..., Sk]`，其中`k >= 1B`，你想一个一个判断`T`是否包含这样的子序列。在这样的情形下，你会怎样修改你的代码呢？思路就是用空间换时间。
> 你可以assume字符都是小写，然后呢`abbacd`可以用一下的2D数组的数据结构存储：
```java
//abbacd => 
[
    [ 0, 1, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [ 3, 1, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [ 3, 2, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [ 3,-1, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [-1,-1, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
]
```
> 你发现了吗？这个字符串的空间变得很大，但是这时候你可以很容易的这个N x 26的矩阵里判断某个字符串是否是`abbacd`的子序列。比如说`aac`，你可以从前往后遍历`aac`的每个字符，当你处理第一个`a`时，你知道a在`aac`中的位置所以是0，那么你就先去矩阵的第0行找有么有`a以及a的最早出现位置`，-> 你找到了结果是0，那么你知道在遍历下一个字符的时候要从第0行之后的那一行进行搜索；这样的搜索算法的时间复杂度就从指数级变成了O(N)级。
>
> 我们再继续深入，看看这个子序类题：[领扣857. 最小的窗口子序列](https://www.lintcode.com/problem/857)，说实话这应该是子序里很难的问题了，属于动归类。子序类的动规题是一个系列，请看[这篇](./coding/dp/subsequence)以加深理解。我们先这里说说`最小的窗口子序列`的思路。原题是给定字符串S和T，在字符串S中找到最小(连续的)子字符串W（窗口），使得T是W的子序列。比如说 `S = "abcdebdde"`， `T = "bde"`，那么它最小的子序窗口应该是`"bcde"`，当然`bdde`也是答案，只不过当遇到长度相等的子序列时候，返回最左边的答案。这题吧，乍一看是懵逼的状态的，但是如果子序类动规题刷多了，如果判断出是子序类动规题，又是两个字符串作为输入，你几乎可以无脑的相信`肯定是两个指针i,j分别遍历两个子串`，`然后判断s1[i]==s2[j]时的逻辑`，`以及判断s1[i]!=s2[j]时的逻辑`。这题也不例外，只不过需要些理解上的技巧。
>
> 按动规的思路，想看看`d[i][j]`的定义是什么：`d[i][j]=index`表示T[0…j] 是S[index…i]的子序列；
>
> 按动规的思路，再看看`d[i][j]`的初始化该怎么做：`d[i][j]=index`表示T[0…j] 是S[index…i]的子序列；
> 1. dp[0][0] 相等为0， 不等为-1
> 1. dp[i][0] 相等为i, 不等为dp[i-1][0]
> 1. dp[0][j] 都为-1 （i<j是不可能包含的）
| (i,j) | a | b | c | d | e | b | d | d | e |
| ---- |:-:| :-:| :-:|:-:| :-:| :-:|:-:| :-:|:-:| 
| b    | -1 | 1 | 1 | 1 | 1 | 5 | 5 | 5 | 5 |
| d    | -1 | X | X | X | X | X | X | X | X |
| e    | -1 | X | X | X | X | X | X | X | X |
>
> 按动规的思路，再看看`d[i][j]`的状态转化方程：
> 1. 当`s[i] == t[j]`时, `d[i][j] = d[i-1][j-1]`
> 1. 当`s[i] != t[j]`时, `d[i][j] = d[i-1][j]` --> 相当于j指针不动，i指针继续匹配，跳过了S中的i指向的字符
| (i,j) | a | b | c | d | e | b | d | d | e |
| ---- |:-:| :-:| :-:|:-:| :-:| :-:|:-:| :-:|:-:| 
| b    | -1 | 1 | 1 | 1 | 1 | 5 | 5 | 5 | 5 |
| d    | -1 | -1 | -1 | 1 | 1 | 1 | 5 | 5 | 5 |
| e    | -1 | -1 | -1 | -1 | 1 | 1 | 1 | 1 | 5 |
