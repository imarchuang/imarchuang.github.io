# 子序概论

#### **敲黑板** 关于子序列的思考
> 子序列(subsequence)的定义：子序列是一个集合里元素的组合，这个组合里的元素之间的前后相对位置要维持的其在原集合里的原序。比如说，`abbacd`这个字符集合，`abd`是其一种子序列，但是`adb`就不是其子序列，因为原字符串里b没有出现在d之后。它于子串/子数组的核心区别就是子序列的元素可以是不连续的，`abd`和`adb`都不是`abbacd`这个字符集合子串，而`abb`就是其子串。所以从数学意义上说，子串/子数组实际上是子序列的一个子集概念。
>
> 子序列问题贯穿所有题型，从纯粹找所有子序列，到子序列的动规问题。因为其**遵循原序**的特殊性，因此在其穷举遍历的方法选择上，通常会更具有技巧性，而且通常会涉及到`动规`的一些遍历手法；
>
> 纯穷举子序列问题，其bigO肯定是O(2^n)；涉及到子序列的时候呢，用动规的遍历技巧通常能达到O(n^2)；
>

#### **敲黑板** 子序列的实例
> 给你一个集合，比如说[1,2,3]，它的子集通常以几种形式呢？
> 1. 所有的子数组：[], [1], [1,2], [1,2,3], [2], [2,3], [3]，因为子数组一定是连续的元素；
> 1. 所有的子序列/子集：[], [1], [1,2], [1,2,3], [2], [2,3], [3], **[1,3]**，因为子序列是可以不连续的元素组成的；
>
> 这里子序列的问题是个O(2^n)的时间复杂度问题，我们看看用java的话怎么写出来：
```java
//写个数学版本的
public List<List<Integer>> getAllSubSequence(int[] nums) {
    List<List<Integer>> res =  new ArrayList<>();
    int count=1<<nums.length; //eg,如果n=3，那么count = 2^3 = 8
    for(int mark=0; mark<count; mark++) {
        List<Integer> temp = new ArrayList<>();
        for(int i=0; i<nums.length; i++){
            if(((1<<i)&mark)!=0)){ //说明nums里第i位置的元素被选中进子集
                temp.add(nums[i]);
            }
        }
        result.add(temp);
    }

    return temp;
}
```
以上数学解法怎么理解呢？
1. 长度为n的数组一共还有2^n-1个子序列；
1. 我们可以这么理解，子序列就是在原序列上取的，那么原序列被取到的话就是1，否则为0.

例如原序列`[1 2 3]`，子序列是`[2]`，那么抽象的结果就是`[0 1 0]`；子序列是`[1 3]`，抽象这是`[1 0 1]`；这最大的优点就是可以用二进制来表示，以下表格可以帮助你更好的理解这个做法。假设我们用nums={1,2,3}这里例子: 下面表格的横向栏位可以用`1<<i`来模拟，比如说001就是`1<<0`结果的二进制表示，010就是`1<<1`结果的二进制表示，100就是`1<<2`结果的二进制表示；至于纵向的行数就更容易理解了，其实就是个计数器`[0...n]`的二进制表示。`(1<<i)&mark)!=0`就很容易判断矩阵里坐标位置的nums[i]是否放进集合。


| &计算结果 | 001   | 010    | 100    |
| -------- |:-----:| :-----:| :-----:|
| 000      | 0     | 0      | 0      |
| 001      | 1     | 0      | 0      |
| 010      | 0     | 1      | 0      |
| 011      | 1     | 1      | 0      |
| 100      | 0     | 0      | 1      |
| 101      | 1     | 0      | 1      |
| 110      | 0     | 1      | 0      |
| 111      | 1     | 1      | 1      |

以上解法更侧重数学思维，面试的时候可以装逼来用用（但是不建议真装逼），不过这题其实是个经典的回溯框架应用问题：
```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        backtrack(path, nums, 0, result);
		return result;
    }
    
    private void backtrack(List<Integer> path, int[] nums, int startIndex, List<List<Integer>> result){
        result.add(new ArrayList<>(path));
        
        for(int i=startIndex; i<nums.length; i++){
            path.add(nums[i]);
            backtrack(path, nums, i+1, result);
            path.remove(path.size()-1);
        }
    }
}
```

> 我们说过了子序、子集问题的时间复杂度大约是O(2^n)，反正肯定是指数级的（**你可以想象成一个多叉树，树的高度是n**）。那么有没有一个更快的算法让我们判断某个组合是不是一个集合的子集呢？请看这题[领扣1263. 是子序列吗？](https://www.lintcode.com/problem/1263/)作为例子。
>
> 例如，给出一个字符串`abbacd`，我么能不能快速的判断`aac`是它的子序，而`bdc`不是它的子序呢？这题的暴力解法就是把字符串的所有子序列都找出来()，然后看有没有包含给出的字符串。其实稍微想一下就知道一个优化办法就是：给出一个`startIndex`，就是看找到某个`字符c`在这个`startIndex`之后出现的第一个(**最早**)位置。
```java
public class Solution {
    /**
     * @param s: the given string s
     * @param t: the given string t
     * @return: check if s is subsequence of t
     */
    public boolean isSubsequence(String s, String t) {
        // Write your code here
        int start = -1;
        for(char c : s.toCharArray()){
            start = isExist(c, t, start);
            if(start==-1) return false; //说明在start位置之后不存在字符c
        }

        return true;
    }

    private int isExist(char c, String t, int startIndex){
        for(int i=startIndex+1; i<t.length();i++){
            if(c == t.charAt(i)){
                return i;
            }
        }

        return -1;
    }
}
```
> 这题的followup也很巧妙：如果输入包含很多`S`串，例如为`[S1, S2, ..., Sk]`，其中`k >= 1B`，你想一个一个判断`T`是否包含这样的子序列。在这样的情形下，你会怎样修改你的代码呢？你看看上题的解法，在`isExist`里的遍历是导致时间的重灾区，总的时间复杂度是O(n*m)，n是s的长度，m是t的长度，下载给你10亿个s，咋办呢？思路就是用空间换时间。
> 你可以assume字符都是小写，然后呢`abbacd`可以用一下的2D数组的数据结构存储：
```java
//abbacd => 
[
    [ 0, 1, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [ 3, 1, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [ 3, 2, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [ 3,-1, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [-1,-1, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
]
```
> 你发现了吗？这个字符串的空间变得很大，但是这时候你可以很容易通过O(m)的复杂度在这个N x 26的矩阵里判断某个字符串是否是`abbacd`的子序列。比如说`aac`，你可以从前往后遍历`aac`的每个字符，当你处理第一个`a`时，你知道a在`aac`中的位置所以是0，那么你就先去矩阵的第0行找有么有`a以及a的最早出现位置`，-> 你找到了结果是0，那么你知道在遍历下一个字符的时候要从第0行之后的那一行（即**第1行**）进行搜索；这样的搜索算法的时间复杂度就从指数级变成了O(M)级。

> 我们再继续深入，看看这个子序类题：[领扣857. 最小的窗口子序列](https://www.lintcode.com/problem/857)，说实话这应该是子序里很难的问题了，属于动归类。子序类的动规题是一个系列，请看[这篇](./coding/dp/subsequence)以加深理解。我们先这里说说`最小的窗口子序列`的思路。原题是给定字符串S和T，在字符串S中找到最小(连续的)子`字符串W`（**窗口**），使得T是W的子序列。比如说 `S = "abcdebdde"`， `T = "bde"`，那么它最小的子序窗口应该是`"bcde"`，当然`bdde`也是答案，只不过当遇到长度相等的子序列时候，返回最左边的答案。
>
> 这题吧，乍一看是懵逼的状态的，你以为是个滑动窗口老猛男题，结果偏偏不是！当然了，你暴力的套老猛男的模板，也是可以得到解的，但重灾区就在于，每次窗口size的增减，你都需要用O(n*m)的复杂度来判断是否为子序列，最终的答案应该是O(n^2*m)级别的。有没有优化呢？
>
> 但是如果子序类动规题刷多了，如果判断出是子序类动规题，又是两个字符串作为输入，你几乎可以无脑的相信`肯定是两个指针i,j分别遍历两个子串`，`然后判断s1[i]==s2[j]时的逻辑`，`以及判断s1[i]!=s2[j]时的逻辑`。这题也不例外，只不过需要些理解上的技巧。
>
> 按动规的思路，状态嘛，就是i和j两个指针。dp的定义呢？`dp[i][j]`的定义是什么：`dp[i][j]=index`表示 `T[0…j]`是`S[index…i]`的子序列；
>
> 按动规的思路，再看看`dp[i][j]`的初始化该怎么做：要看`s.charAt(i)`和`t.charAt(j)`这两个字符是否相等。
> 1. 如果`s[0]==t[0]`，那么`dp[0][0]=0`， 否则（不等）`dp[0][0]=-1`（-1表示`S[0…i]`中没办法包括`T[0…j]`）;
> 1. 如果`s[0]==t[0]`，那么`dp[i][0]=i`, 否则（不等）`dp[i][0]=dp[i-1][0]`;
> 1. `dp[0][j]` 都为-1，因为当`i<j`时，S’的长度是小于T‘的，所以`S[0…0]`中没办法包括`T[0…j]`;
| (i,j) | a | b | c | d | e | b | d | d | e |
| ---- |:-:| :-:| :-:|:-:| :-:| :-:|:-:| :-:|:-:| 
| b    | -1 | 1 | 1 | 1 | 1 | 5 | 5 | 5 | 5 |
| d    | -1 | X | X | X | X | X | X | X | X |
| e    | -1 | X | X | X | X | X | X | X | X |
>
> 按动规的思路，现在来看看`dp[i][j]`的状态转化方程：
> 1. 当`s[i] == t[j]`时, `d[i][j] = d[i-1][j-1]`，相当于这两个字符不影响，所以可以跳过；
> 1. 当`s[i] != t[j]`时, `d[i][j] = d[i-1][j]` --> 相当于j指针不动，i指针继续匹配，跳过了S中的i指向的字符；
| (i,j) | a | b | c | d | e | b | d | d | e |
| ---- |:-:| :-:| :-:|:-:| :-:| :-:|:-:| :-:|:-:| 
| b    | -1 | 1 | 1 | 1 | 1 | 5 | 5 | 5 | 5 |
| d    | -1 | -1 | -1 | 1 | 1 | 1 | 5 | 5 | 5 |
| e    | -1 | -1 | -1 | -1 | 1 | 1 | 1 | 1 | 5 |
