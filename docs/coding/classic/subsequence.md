# 子序概论

#### **敲黑板** 关于子序列的思考
> **子序列**(`subsequence`)的定义：子序列是一个集合里元素的组合，这个组合里的元素之间的前后相对位置要维持的其在原集合里的**原序**，所以才称之为子**序列**。比如说，`abbacd`这个字符集合，`abd`是其一种子序列，但是`adb`就不是其子序列，因为原字符串里b没有出现在d之后。它于子串/子数组的核心区别就是子序列的元素可以是不连续的，`abd`和`adb`都不是`abbacd`这个字符集合子串，而`abb`就是其子串。所以从数学意义上说，子串/子数组实际上是子序列的一个子集概念。
>
> 子序列问题贯穿所有题型，从纯粹找所有子序列，到子序列的动规问题。因为其**遵循原序**的特殊性，因此在其穷举遍历的方法选择上，通常会更具有技巧性，而且通常会涉及到`动规`的一些遍历手法；但是有一点是确定的，因为子序需要遵循原序，所以遍历一定是**单向性**的。
>
> 纯穷举子序列问题，其bigO肯定是O(2^n)；涉及到子序列的时候呢，用动规的遍历技巧通常能达到O(n^2)；甚至有时候你借助**单调栈**的技巧更加聪明的遍历，你可以O(n)复杂度把问题秒了。
>

#### **敲黑板** 子序列的实例
> 给你一个集合，比如说[1,2,3]，它的子集通常以几种形式呢？
> 1. 所有的子数组：[], [1], [1,2], [1,2,3], [2], [2,3], [3]，因为子数组一定是连续的元素；
> 1. 所有的子序列/子集：[], [1], [1,2], [1,2,3], [2], [2,3], [3], **[1,3]**，因为子序列是可以不连续的元素组成的；
>
> 这里子序列的问题是个O(2^n)的时间复杂度问题，我们看看用java的话怎么写出来：
```java
//写个数学版本的
public List<List<Integer>> getAllSubSequence(int[] nums) {
    List<List<Integer>> res =  new ArrayList<>();
    int count=1<<nums.length; //eg,如果n=3，那么count = 2^3 = 8
    for(int mark=0; mark<count; mark++) {
        List<Integer> temp = new ArrayList<>();
        for(int i=0; i<nums.length; i++){
            if(((1<<i)&mark)!=0)){ //说明nums里第i位置的元素被选中进子集
                temp.add(nums[i]);
            }
        }
        result.add(temp);
    }

    return temp;
}
```
以上数学解法怎么理解呢？
1. 长度为n的数组一共还有2^n-1个子序列；
1. 我们可以这么理解，子序列就是在原序列上取的，那么原序列被取到的话就是1，否则为0.

例如原序列`[1 2 3]`，子序列是`[2]`，那么抽象的结果就是`[0 1 0]`；子序列是`[1 3]`，抽象这是`[1 0 1]`；这最大的优点就是可以用二进制来表示，以下表格可以帮助你更好的理解这个做法。假设我们用nums={1,2,3}这里例子: 下面表格的横向栏位可以用`1<<i`来模拟，比如说001就是`1<<0`结果的二进制表示，010就是`1<<1`结果的二进制表示，100就是`1<<2`结果的二进制表示；至于纵向的行数就更容易理解了，其实就是个计数器`[0...n]`的二进制表示。`(1<<i)&mark)!=0`就很容易判断矩阵里坐标位置的nums[i]是否放进集合。


| &计算结果 | 001   | 010    | 100    |
| -------- |:-----:| :-----:| :-----:|
| 000      | 0     | 0      | 0      |
| 001      | 1     | 0      | 0      |
| 010      | 0     | 1      | 0      |
| 011      | 1     | 1      | 0      |
| 100      | 0     | 0      | 1      |
| 101      | 1     | 0      | 1      |
| 110      | 0     | 1      | 0      |
| 111      | 1     | 1      | 1      |

以上解法更侧重数学思维，面试的时候可以装逼来用用（但是不建议真装逼），不过这题其实是个经典的回溯框架应用问题：
```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        backtrack(path, nums, 0, result);
		return result;
    }
    
    private void backtrack(List<Integer> path, int[] nums, int startIndex, List<List<Integer>> result){
        result.add(new ArrayList<>(path));
        
        for(int i=startIndex; i<nums.length; i++){
            path.add(nums[i]);
            backtrack(path, nums, i+1, result);
            path.remove(path.size()-1);
        }
    }
}
```

> 我们说过了回溯框架的时间复杂度大约是O(2^n)，反正肯定是指数级的（**你可以想象成一个多叉树，树的高度是n**）。那么有没有一个更快的算法让我们判断某个组合是不是一个集合的子集呢？请看这题[领扣1263. 是子序列吗？](https://www.lintcode.com/problem/1263/)作为例子。
>
> 例如，给出一个字符串`abbacd`，我么能不能快速的判断`aac`是它的子序，而`bdc`不是它的子序呢？这题的暴力解法就是把字符串的所有子序列都找出来()，然后看有没有包含给出的字符串。其实稍微想一下就知道一个优化办法就是**聪明的遍历**：给出一个`startIndex`，就是看找到某个`字符c`在这个`startIndex`之后出现的第一个(**最早**)位置。
```java
public class Solution {
    /**
     * @param s: the given string s
     * @param t: the given string t
     * @return: check if s is subsequence of t
     */
    public boolean isSubsequence(String s, String t) {
        // Write your code here
        int start = -1;
        for(char c : s.toCharArray()){
            start = isExist(c, t, start);
            if(start==-1) return false; //说明在start位置之后不存在字符c
        }

        return true;
    }

    private int isExist(char c, String t, int startIndex){
        for(int i=startIndex+1; i<t.length();i++){
            if(c == t.charAt(i)){
                return i;
            }
        }

        return -1;
    }
}
```
> 这题的**followup**也很巧妙：如果输入包含很多`S`串，例如为`[S1, S2, ..., Sk]`，其中`k >= 1B`，你想一个一个判断`T`是否包含这样的子序列。在这样的情形下，你会怎样修改你的代码呢？你看看上题的解法，在`isExist`里的遍历是导致时间的重灾区，总的时间复杂度是O(n*m)，n是s的长度，m是t的长度，下载给你10亿个s，咋办呢？思路就是用空间换时间。
> 你可以assume字符都是小写(也就是说26个小写字母)，然后呢`abbacd`可以用一下的**2D数组**的数据结构存储，你仔细体会体会这里的妙处，把一个长度为6的字符串，转成一个`26x6`的矩阵，这样S中的每个字符在**第i元素位置之后**的最早出现的位置就一目了然了：
```java
//abbacd => 
[
    [ 0, 1, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [ 3, 1, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [ 3, 2, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [ 3,-1, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [-1,-1, 4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
    [-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
]
```
> 你发现了吗？这个字符串的空间变得很大，但是这时候你可以很容易通过O(m)的复杂度在这个N x 26的矩阵里判断某个字符串是否是`abbacd`的子序列。比如说`aac`，你可以从前往后遍历`aac`的每个字符，当你处理第一个`a`时，你知道a在`aac`中的位置所以是0，那么你就先去矩阵的第0行找有么有`a以及a的最早出现位置`，-> 你找到了结果是0，那么你知道在遍历下一个字符的时候要从第0行之后的那一行（即**第1行**）进行搜索；这样的搜索算法的时间复杂度就从指数级变成了O(M)级。

> 我们再继续深入，看看这个子序类题：[领扣857. 最小的窗口子序列](https://www.lintcode.com/problem/857)，说实话这应该是子序里很难的问题了，属于动归题。子序类的动规题是一个系列，请看[这篇](./coding/dp/decision)以加深理解。我们先这里说说`最小的窗口子序列`的思路。原题是给定字符串S和T，在字符串S中找到最小(连续的)子`字符串W`（**窗口**），使得T是W的子序列。比如说 `S = "abcdebdde"`， `T = "bde"`，那么它最小的子序窗口应该是`"bcde"`，当然`bdde`也是答案，只不过当遇到长度相等的子序列时候，返回最左边的答案。
>
> 这题吧，乍一看是懵逼的状态的，你以为是个滑动窗口**老猛男**题，结果偏偏不是！当然了，你暴力的套老猛男的模板，也是可以得到解的，但重灾区就在于每次窗口size的增减，你都需要用O(n*m)的复杂度来判断是否为子序列，最终的答案应该是O(n^2*m)级别的。有没有优化呢？
>
> 但是如果子序类动规题刷多了，如果判断出是子序类动规题，又是两个字符串作为输入，你几乎可以无脑的相信`肯定是两个指针i,j分别遍历两个子串`，`然后判断s1[i]==s2[j]时的逻辑`，`以及判断s1[i]!=s2[j]时的逻辑`。这题也不例外，只不过需要些理解上的技巧。
>
> 按动规的思路，**状态**嘛，就是`i和j`两个指针。dp函数/数组的定义呢？`dp[i][j]`的定义是什么：`dp[i][j]=k`表示`T[0…j]`是`S[k…i]`的子序列；举个例子吧，假设`S="abcdebdde"`, `T="bde"`, 那么你沿着双子序问题的思考思路，就是针对i和j**遵循同向遍历**原理暴力穷举两个变量的可能值嘛，这里我们**子问题**的最小值就是**单个字符**嘛，假设`i==0`且`j==0`，那么你琢磨琢磨怎样判断`T[0]`是不是`S[0]`的子序呢？就看是不是相等就得了。现在继续思考，假设我们锚定`j==0`，然后让在**i方向上遍历**直到n-1，那么我们怎么来判断`T[0]`是不是`S[k...i]`的子序呢？这里你肯定会问为啥要冒出这个`k`呢？这里就要说到原题所要求的答案了，因为原题要求的是**最小子串窗口W**，我们当然是希望`k`越接近`i`越好对吧？所以**base case**可以这么表达：
> 1. 锚定`j==0`，遍历`0<=i<m`，那么dp[i][0]的初始值可以这么算：
>       * 如果`s[i]==t[0]`，那么`dp[i][0]=i`；这个`i`值就是我们上面说到的`k`，也就是说当两个字符相等的时候，我们能找到的**最小子串窗口W**一定是`S[i...i]`就是说`S[i]`单字符本身(单字符为子串的窗口W)；这样我们就巧妙的记录了当`T[0…j]`是`S[k…i]`的子序列时`k`的最大可能的值(`k`越大，说明**窗口W**越小)；记录这个k当然还不是最终要求的答案，但是记录这个k值会使我们之后能计算答案。
>       * 如果`s[i]!=t[0]`，那么`dp[i][0]=dp[i-1][0]`；这里意思就是**跳过**当前字符`S[i]`；
> 1. 上面提到了锚定`j==0`，我们有两个自变量嘛，所以我们也要讨论一下锚定`i==0`且`0<j<n`的情况。
>       * `dp[0][j]=-1`当`0<j<n`，因为当`i<j`时，子串`S[0...0]`的长度是小于`T[0...j]`的，所以`S[0…0]`中没办法包括`T[0…j]`;
>
| (i,j) | a | b | c | d | e | b | d | d | e |
| ---- |:-:| :-:| :-:|:-:| :-:| :-:|:-:| :-:|:-:| 
| b    | -1 | 1 | 1 | 1 | 1 | 5 | 5 | 5 | 5 |
| d    | -1 | X | X | X | X | X | X | X | X |
| e    | -1 | X | X | X | X | X | X | X | X |
>
> 说完了**重复子问题**和**base case**，现在我们再来看看`dp[i][j]`**状态转化方程**，这里还是符合双序列的套路，你是否还记得双子序的四个选择？`两个都跳过`，`跳S[i]元素`，`跳T[j]元素`，`两个都不跳`:
> 1. 当`s[i] == t[j]`时是啥情况呢？还记得吗？我们原题要求的是**最小子串窗口W**，而且我们dp数组记录的是`T[0…j]`是`S[k…i]`的子序列的最大的k值，按照这个思路，你是不是可以这么说：我可以把这两个字符`s[i]`和`t[j]`选择`两个都不跳`对吧？这么理解吧，假设`T[0…j-1]`是`S[k…i-1]`的子序列，那么`T[0…j]`也一定是`S[k…i]`的子序列！因为**s[i] == t[j]**。这样我们就可以用这个转化方程：`dp[i][j] = dp[i-1][j-1]`；
> 1. 当`s[i] != t[j]`时是啥情况呢？这时候吧，你没有跳其中你一个元素的选择，而是你只能跳过`S[i]`这个元素，因为要使`T[0…j]`是`S[k…i]`继续成立，你必须继续**增加i的值**继续寻找。这样我们就可以用这个转化方程：`d[i][j] = d[i-1][j]`，也就是相当于`j指针`不动，i指针继续匹配，**跳过**了S中的`i`指向的字符；
| (i,j) | a | b | c | d | e | b | d | d | e |
| ---- |:-:| :-:| :-:|:-:| :-:| :-:|:-:| :-:|:-:| 
| b    | -1 | 1 | 1 | 1 | 1 | 5 | 5 | 5 | 5 |
| d    | -1 | -1 | -1 | 1 | 1 | 1 | 5 | 5 | 5 |
| e    | -1 | -1 | -1 | -1 | 1 | 1 | 1 | 1 | 5 |
>
> 当我们拿到了这个dp数组，问题让我们求的是最终的子串窗口W嘛，那我们就遍历S[0...m]好了，要用`i-f[i][n-1]`来算长度，因为`f[i][n-1]`的值表示的整个字符串T是`S[k…i]`的子序列，这里k就是`f[i][n-1]`。直接看最终代码吧：
```java
public String minWindow(String s, String t) {
        int m = s.length(), n = t.length();
        if(m == 0 || n == 0) return "";
        int[][] dp = new int[m][n];        
        dp[0][0] = s.charAt(0) == t.charAt(0) ? 0 : -1;
        for(int i = 1; i< m; i++) {//要对f[i][j] 的含义非常清楚就不会写错
            dp[i][0] = s.charAt(i) == t.charAt(0) ? i : dp[i-1][0];
        }
        for(int j = 1; j< n; j++) {
            dp[0][j] = -1;
        }
        for(int j = 1; j < n; j++) {
            for(int i = 1; i< m; i++) {//f[i][j] = index, T[0..j] 是S[index..i]的子序列,index值
                if(s.charAt(i) == t.charAt(j)) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        int min = Integer.MAX_VALUE;
        String res = "";        
        for(int i = 0; i< m; i++) {            
            if(dp[i][n-1] != -1 && i - dp[i][n-1] + 1 < min) {//dp里存的是startIndex
                    min = i - dp[i][n-1] + 1; //窗口长度： endIndex- startIndex+1
                    res = s.substring(dp[i][n-1], i+1);//java的endindex不包含，所以需要+1
            }
        } 
        return res;

    }
}
```

> 上面的解法呢，时间复杂度是O(n*m)，思路更多的是集中在你找出了这题的双子序动规的特点来了，去套双子序动规的套路模板，然而我觉得不是每个人都能快速的想到dp数组要记录k值的这个动规特性。所以我这里讲一个更加简单想到也更加**通用**的思路。
>
> 话说我们之前提到过把一个字符串或者数列的一维的数据结构扩张到二维数组的数据结构，叫做**升维打击法**，这里因为是个**序列**问题，所以扩展到二维的时候，不仅要保持一维时候的原值(在i行维上)，还要在记录每个原值在原数组中的位置(在j列维上)。比如所给你一个只含小写字符的字符串`abcdebdde`，你就可以把这个长度为9的字符串扩张成一个**9x26**大小的二维数组：
```java
//abcdebdde => 
[
    [  0, 1, 2, 3, 4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1], //第0行
    [ -1, 1, 2, 3, 4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1], //第1行
    [ -1, 5, 2, 3, 4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1], //第2行
    [ -1, 5,-1, 3, 4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1], //第3行
    [ -1, 5,-1, 6, 4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1], //第4行
    [ -1, 5,-1, 6, 8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1], //第5行
    [ -1,-1,-1, 6, 8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1], //第6行
    [ -1,-1,-1, 7, 8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1], //第7行
    [ -1,-1,-1,-1, 8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]  //第8行
]
```
>1. 有了这两个信息，你可以做什么？首先你能想到肯定可以会用O(m)的时间复杂度确认一个字符串`t`(t的长度为m)是不是字符串`s="abcdebdde"`的子序列对吧？这个怎么做呢？其实就是从左往右遍历`t`的每个字符，确认`t`中的每一个字符`c_cur`可以在**二维数组的某一行之后**出现，这里的`某一行`就是根据`t`中上一个字符`c_prev`最早出现的位置，这个思路我们之前也讨论过。
>1. 基于上边的思路，你仔细琢磨琢磨，有了这个二维数组，你不止可以判断字符串`t`是不是字符串`s="abcdebdde"`的子序列，我其实也可以判断字符串`t`是不是字符串`s="abcdebdde"`的**任意字串**的子序列，这个子串我们就用`s[start, end)`这个左闭右开的区间来表示，而且时间复杂度也是O(m)。这个怎么做呢？思路基本相同，那就是从左往右遍历`t`的每个字符，确认每一个字符`c_cur`可以在**二维数组的某一行之后**出现，这里的`某一行`就是根据上一个字符`c_prev`最早出现的位置，不过呢，我们还得加一个条件，那就是那个`某一行`不仅是上一个字符`c_prev`最早出现的位置，而且这个`某一行`必须不能超过**end**。
>
> 现在你知道了有个`isSubSeq(s[start, end))`这个函数的话，你是不是能够想到滑动窗口老猛男的解法了？就是同向双指针嘛，一左一右，根据是否能将`t`纳为一个子序列来决定窗口的扩张还是缩小。
>
> 这个思路的时间复杂度也是O(n*m)。讲到这儿了，直接看代码吧：
```java
public class Solution {
    public String minWindow(String s, String t) {

        //先建一个二维数组把每个字符的ascii存起来，
        int n = s.length();
        int[][] memo = new int[n][26];

        //把最下一行进行init，之后再一行一行的像是填充数据
        for(int j=0; j<26; j++){
            memo[n-1][j]=-1;
        }

        //遍历每个字符，让每个字符str.charAt(i)都填入相应的位置
        for(int i=n-1; i>=0; i--){
            //memo[i][j] 表示串str的第i个位置起, 下标最靠前的字符 str[j] (ascii代码-97) 的位置.
            memo[i][(int) s.charAt(i)-'a'] = i;
            if(i==0) break;
            
            //把当前行的数据，先拷贝一份去上一行
            for(int j=0; j<26; j++){
                memo[i-1][j] = memo[i][j];
            }
        }

        //接下来就是老猛男套路
        int left=0, right=t.length()-1;
        int min = Integer.MAX_VALUE;
        String res = "";
        while(right<=n){ 
            while(isSubseq(t, memo, left, right)){
                if(right-left<min){
                    min=right-left;
                    res = s.substring(left, right);
                }
                //System.out.println(left+"|"+right+"|"+res);
                left++;
            }
            right++;
        }
        return res;

    }

    //在S[start, end]区间里看t是不是它的子序列
    private boolean isSubseq(String t, int[][] memo, int start, int end){
        int lenw = t.length();
        int lens = memo.length;
        int i=0,j=start;
        for(; i < lenw && j < end; i++, j++){
            //System.out.println("before:"+j+"|"+i);
            j = memo[j][t.charAt(i) - 'a'];
            //System.out.println("after:"+j+"|"+i);
            if (j < 0) 
                return false;
            if(j>=end) 
                return false;
        }
        return i == lenw;
    }
}
```
