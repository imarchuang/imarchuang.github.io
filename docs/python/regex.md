# Regex是时候了

## 所谓的元字符Metacharacters: `$` `^` `{` `[` `(` `|` `)` `]` `}` `*` `+` `?`
> **Metacharacters** 很久以前Perl和Shell对Regex的支持是公认的，现在呢几乎所有语言都有了很好的支持，比如说Java/C#，Python，Javascript，Go等，有个比较好的现象就是他们在支持regex的时候都遵从了同样的Metacharacters协议。
>1. **'*'**: 俗称万能通配符，是一个**quantifier量记号**，意思是**0个或者多个**前一个expression匹配的字符(串)。
>       * 一个比较好的例子就是`ab*c`，表示匹配0个或者多个**b**，这样的话`ac`，`abc`，`abbc`，`abbbc`，`abbbbc`...都可以匹配；
>       * 前提就是必须是个字符，那就是说至少占了一个8个字节的才能称之为字符，你可以配合是一个**quantifier量记号**使用，比如说你想要匹配**0个到多个某任意字符**，你就需要这么写了万能中的万能匹配：`.*`；
>1. **'+'**: 对应着 **'*'** 通配符，也是一个**quantifier量记号**，这里`+`表示匹配**1个或者多个**前一个expression匹配的字符(串)；
>       * 一个比较好的例子就是`ab+c`，表示匹配1个或者多个**b**，这样的话`abc`，`abbc`，`abbbc`，`abbbbc`...都可以匹配；
>1. **'?'**: 也是对应着 **'*'** 通配符，也是一个**quantifier量记号**，这里`?`表示匹配**0个或者1个**前一个expression匹配的字符(串)；
>       * 一个比较好的例子就是`labell?ed`，表示匹配1个或者多个**l**，这样的话`labeled`，`labelled`都可以匹配；
>       * **Note：** `?` 也可以用来表达一个表达式是greedy还是lazy，请看第三个section；
>1. **'.'**: 俗称通配符，匹配除了`\n`之外的任何字符，有个前提就是必须是个字符；
>       * 例子`a.c`，表示匹配a和c中间可以存在1个(且只能1个)任意字符(必须是个字符)，这样的话`abc`，`aac`，`acc`，`adc`，`aec`...都可以匹配；
>1. **'|'**: 俗称`显式集匹配`，这里`|`表示匹配**A或B**；
>       * 例子`bill|ted`，表示匹配**bill或ted**，这样的话`bill`，`ted`都可以匹配；
>1. **'[...]'**: 俗称**匹配集**，表示匹配 **[...]里指定的匹配表达式集合**；集合里的元素支持很多logical operator，比如说 **`^`(非), `-`(减号), `&&`(并)等**
>       * 一个比较好的例子`[A-Z][a-z]*`，表示匹配**1个任意大写字符[A-Z]，后面紧跟着0个或者多个小写字符**，这样的话`Wally`，`E`都可以匹配；
>       * **Note：** 特殊字符Metacharacters放入匹配集里会变成literal，比如说`[$*+]`，表示匹配**这3个字符(`$`,`*`,`+`)里的一个**，这样的话`*`，`$`，`+`都可以匹配，**这里当然不包括`^`(非), `-`(减号), `]`(介绍信号符), `\`(转义字符本身), `&&`(加法) 等**；
>       * **Note：** **否** 匹配符在 **'[...]'** 可以配合使用，比如说`[^a-z]`，表示匹配**1个字符`非`小写字母**，这样的话`E`，`A`，`D`...都可以匹配；
>       * **Note：** 指定set里的元素时候，可以配合**range**的语法使用，**range**概念是用`hyphen (–)`来表达的，比如所说`[0-9a-fA-F]`等；
>       * **Note：** 指定set里的元素时候，还可以**做加减法**，比如说`[a-z-[aeiuo]]`表示匹配所有的`not a vowel`英文字母字符，同样的你想要用加法的话，可以这么写`[a-z&&[^aeiuo]]`；
>1. **'{...}'**: 俗称**显式quantifier记号**，表示可以指定前一个expression匹配的字符(串)的发生次数；
>       * 一个比较好的例子就是`\d{3}-\d{3}-\d{4}`，表示匹配**3个连续数字符跟着`-`之后跟着3个连续数字符，之后跟着`-`和4个连续数字符**，也就是美国电话号码格式，这样的话`555-555-4321`之类的都可以匹配了；
>       * **Note** 不仅可以显式指定特殊特定的次数，还可以表达一个**range**的记号，比如说`\d{3,}`表示至少3个数字符，这样'12'这种字符串就匹配不了了，再比如`\d{3,6}`表示可以**3个至6个(包含6)数字符**，这样'1234567'这种字符串就匹配不了了；
>1. **`^` `$`**: 常规语境context里，表达的是每一行的开始`(^)`和结束`($)`；
>       * 一个比较好的例子`^Python$`，表示匹配**整行的内容必须是Python这些**，这样的话`Python is..`就匹配不了；
>       * **Note：** 上面提到过，`(^)`放到 **'[...]'**匹配集里时，表示**否**。比如说`[^a-z]`，表示匹配**1个字符`非`小写字母**，这样的话`E`，`A`，`D`...都可以匹配；
>1. **'(...)'**: 俗称**子表达式**，子表达式的好处就是可以**缓存**匹配的结果在一个groupby的result list里，但是access这个result list是从index 1开始的；
>       * **子表达式**应用很广，举个简单例子，`([A-Z][a-z]+ [A-Z][a-z]+), email: (\w+@\w+\.\w{3})`去匹配这个句子`Charlie Cyan, email: demo1@marc.com`，那么匹配结果分为match和group，用Python的话，match可以用`result = re.search(pattern, text).group()`access，结果就是整个句子`Charlie Cyan, email: demo1@marc.com`，这个结果里也可以按照子表达式的groupby结果来access，比如说Python里可以写`result = re.search(pattern, text).groups()`，结果就是`('Charlie Cyan', 'demo1@marc.com')`，按照每个坐标去access的话，要从1开始，比如说`result = re.search(pattern, text).group(1)`，结果就是`'Charlie Cyan'`；
>1. **'\\'**: 俗称**转义字符**，表示后面跟的字符需要被转义，这个例子就多了去了，但是这里重点介绍一些特殊情况；
>       * 转义**元字符本身**，比如说你想匹配`^$`这些字符本身，那么你就需要这么写`\^\$`；
>       * 转义**非特殊字符**本身，比如说你写`\z`，那么这个跟写`z`是一个效果的；
>       * * **Note：** 看下一段落；

## 转义字符: `\`
> 这些转义字符全记住也不现实，当时常用的character classes必须得知道
> 1. **'\s'**: 匹配whitespace类的字符，这包括`\t`, `\n`, `\r`, `\f`, `\v` 等
> 1. **'\S'**: 匹配**非whitespace类**的字符
> 1. **'\w'**: 匹配word类字符，基本上等同于26个英文字母大小写加10个数字符`[a-zA-Z_0-9]`，包括下划线**`_`**字符
> 1. **'\W'**: 匹配**非word类**字符，基本上等同于26个英文字母大小写加10个数字符`[a-zA-Z_0-9]`以外的字符
> 1. **'\d'**: 匹配**数字符**字符，等同于`[0-9]`
> 1. **'\D'**: 匹配**非数字符**字符，等同于`[^0-9]`
> 1. **'\p{name}'**: 匹配**其他常用的character classes**字符，比如说`[\p{Digit}\p{Lower}]`就是要匹配**0到9或者a到z**；这个常用的classes是否支持要看语言对POSIX的支持，Perl里的支持比较广泛，比如说`\pL`意思就是匹配所有的字母(Letter)，`\pLu`意思就是匹配所有的大写字母(Letter upper)；
> 1. **'\P{name}'**: 上一个匹配的**非**

## 关于greedy和lazy的妙用
[看看这个](https://javascript.info/regexp-greedy-and-lazy)